# Установка переменной среды для избежания конфликта с OpenMP
import os
os.environ['KMP_DUPLICATE_LIB_OK'] = 'TRUE'

# Основные импорты для работы бота
import logging
import os
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# Для работы с данными и файлами
import json
from cryptography.fernet import Fernet
import pandas as pd
from openpyxl import load_workbook

# Для базы данных и аналитики
import sqlite3
from datetime import datetime
from functools import wraps

# Для обработки изображений и компьютерного зрения
import cv2
import numpy as np
from pathlib import Path
import torch
from torchvision import transforms, models
from PIL import Image
import faiss
import pickle
from PIL import ImageEnhance
import uuid
import requests
from io import BytesIO
import time

# Новые импорты для CLIP
from transformers import CLIPProcessor, CLIPModel
import clip

# Новый импорт для YOLO
from ultralytics import YOLO

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Глобальные переменные для моделей
image_model = None
feature_extractor = None
faiss_index = None
label_encoder = None
# Новые переменные для CLIP
clip_model = None
clip_processor = None
clip_device = "cuda" if torch.cuda.is_available() else "cpu"
# Новая переменная для модели YOLO
yolo_model = None
# Флаг использования Cloudinary вместо локального поиска - всегда False
use_cloudinary = False
# Новый флаг для включения улучшенного поиска
use_enhanced_search = True  # Включаем улучшенный поиск

def load_config(encrypted_file="config.encrypted"):
    """Загружает конфигурацию из зашифрованного файла"""
    try:
        # Загружаем ключ шифрования
        with open("key.key", "rb") as key_file:
            key = key_file.read()

        # Создаем объект шифрования
        fernet = Fernet(key)

        # Читаем зашифрованные данные
        with open(encrypted_file, "rb") as config_file:
            encrypted_data = config_file.read()

        # Расшифровываем данные
        decrypted_data = fernet.decrypt(encrypted_data)
        config = json.loads(decrypted_data.decode())

        logger.info("✅ Конфигурация успешно загружена")
        return config
    except Exception as e:
        logger.error(f"❌ Ошибка при загрузке конфигурации: {e}")
        return None

def is_allowed_user(user_id):
    """Проверяет, есть ли пользователь в белом списке"""
    try:
        config = load_config()
        whitelist = config.get('whitelist', [])
        return user_id in whitelist
    except Exception as e:
        logger.error(f"Ошибка при проверке пользователя: {e}")
        return False

def is_admin(user_id):
    """Проверяет, является ли пользователь администратором"""
    try:
        config = load_config()
        admins = config.get('admins', [])
        return user_id in admins
    except Exception as e:
        logger.error(f"Ошибка при проверке администратора: {e}")
        return False

def initialize_image_search():
    """Инициализация моделей и индексов для поиска изображений с использованием CLIP"""
    global image_model, feature_extractor, faiss_index, label_encoder
    global clip_model, clip_processor
    
    try:
        logger.info(f"Инициализация моделей на устройстве: {clip_device}")
        
        # Инициализируем модель CLIP
        try:
            # Пробуем сначала загрузить модель через трансформеры
            clip_model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32")
            clip_processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")
            logger.info("✅ Модель CLIP загружена через transformers")
        except Exception as e:
            logger.warning(f"Не удалось загрузить CLIP через transformers: {e}")
            # Пробуем загрузить через оригинальную библиотеку CLIP
            clip_model, clip_processor = clip.load("ViT-B/32", device=clip_device)
            logger.info("✅ Модель CLIP загружена через оригинальную библиотеку")
        
        # Переводим модель в режим оценки
        clip_model.eval()
        
        # Получаем размерность вектора от CLIP (обычно 512)
        if hasattr(clip_model, 'visual') and hasattr(clip_model.visual, 'output_dim'):
            feature_dim = clip_model.visual.output_dim
        else:
            feature_dim = 512  # Стандартный размер для CLIP ViT-B/32
        
        logger.info(f"Размерность признаков CLIP: {feature_dim}")
        
        # Создаем индекс FAISS
        faiss_index = faiss.IndexFlatL2(feature_dim)
        
        # Загружаем существующий индекс если есть
        if os.path.exists('clip_image_search_index.pkl'):
            try:
                with open('clip_image_search_index.pkl', 'rb') as f:
                    saved_data = pickle.load(f)
                    faiss_index = saved_data['index']
                    label_encoder = saved_data['labels']
                    # Загружаем метаданные инструментов если они есть
                    tool_metadata = saved_data.get('tool_metadata', {})
                logger.info(f"Загружен существующий CLIP индекс с {faiss_index.ntotal} изображениями")
            except Exception as e:
                logger.error(f"Ошибка при загрузке индекса CLIP: {e}")
                # Создаем новый индекс
                faiss_index = faiss.IndexFlatL2(feature_dim)
                label_encoder = []
        else:
            label_encoder = []
        
        logger.info("✅ Модели поиска изображений CLIP успешно инициализированы")
        return True
        
    except Exception as e:
        logger.error(f"❌ Ошибка при инициализации моделей CLIP: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return False

def extract_features(image_path):
    """Извлечение признаков из изображения с использованием CLIP и дополнительной обработкой для инструментов в коробках"""
    try:
        # Проверка на существование файла
        if not os.path.exists(image_path):
            logger.error(f"Файл не существует: {image_path}")
            return None
            
        # Загружаем изображение
        original_image = Image.open(image_path).convert('RGB')
        logger.info(f"Извлечение признаков CLIP из изображения: {os.path.basename(image_path)}")
        
        # Загружаем изображение через OpenCV для предобработки
        cv_img = cv2.imread(str(image_path))
        if cv_img is None:
            logger.warning(f"Не удалось загрузить изображение через OpenCV, используем PIL: {image_path}")
            # Используем оригинальное изображение через PIL
            image = original_image
        else:
            # Проверяем, может ли это быть инструмент в коробке
            has_box = detect_tool_box(cv_img)
            
            # Если обнаружена коробка, пытаемся извлечь инструмент
            if has_box:
                logger.info(f"Обнаружен инструмент в коробке, применяем специальную обработку")
                # Получаем обрезанное изображение с инструментом
                roi_img = extract_tool_from_box(cv_img)
                if roi_img is not None:
                    # Конвертируем обратно в PIL
                    image = Image.fromarray(cv2.cvtColor(roi_img, cv2.COLOR_BGR2RGB))
                    logger.info(f"Извлечен инструмент из коробки")
                else:
                    # Если не удалось извлечь, используем оригинал
                    image = original_image
                    logger.info(f"Не удалось извлечь инструмент из коробки, используем полное изображение")
            else:
                # Используем оригинальное изображение
                image = original_image
        
        # Предобработка для улучшения результатов
        # Повышаем контрастность
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(1.3)  # Увеличиваем контраст на 30%
        
        # Повышаем резкость для лучшего распознавания деталей
        enhancer = ImageEnhance.Sharpness(image)
        image = enhancer.enhance(1.2)  # Увеличиваем резкость на 20%
        
        with torch.no_grad():
            # Используем процессор CLIP для предобработки изображения
            if isinstance(clip_processor, CLIPProcessor):
                # Для варианта из transformers
                inputs = clip_processor(images=image, return_tensors="pt")
                image_features = clip_model.get_image_features(**inputs)
                image_features = image_features.cpu().numpy()[0]
            else:
                # Для оригинальной библиотеки CLIP
                image_tensor = clip_processor(image).unsqueeze(0).to(clip_device)
                image_features = clip_model.encode_image(image_tensor)
                image_features = image_features.cpu().numpy()[0]
            
            # Нормализуем вектор
            image_features = image_features / np.linalg.norm(image_features)
            
            logger.info(f"Успешно извлечены CLIP признаки из {os.path.basename(image_path)}, размерность: {image_features.shape}")
            
            return image_features
            
    except Exception as e:
        logger.error(f"Ошибка при извлечении признаков CLIP: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return None

def detect_brand_from_filename(filename):
    """Определение бренда инструмента по имени файла"""
    # Известные бренды инструментов с более точными ключевыми словами
    known_brands = {
        # Makita
        'makita': 'Makita',
        'макита': 'Makita',
        
        # Dexter
        'dexter': 'Dexter',
        'декстер': 'Dexter',
        
        # DeWalt
        'dewalt': 'DeWalt',
        'девольт': 'DeWalt',
        'dewat': 'DeWalt',
        
        # Bosch
        'bosch': 'Bosch',
        'бош': 'Bosch',
        
        # Metabo
        'metabo': 'Metabo',
        'метабо': 'Metabo',
        
        # Ryobi
        'ryobi': 'Ryobi',
        'риоби': 'Ryobi',
        
        # Hitachi/Hikoki
        'hitachi': 'Hitachi',
        'hikoki': 'Hitachi',
        'хитачи': 'Hitachi',
        'хикоки': 'Hitachi',
        
        # Milwaukee
        'milwaukee': 'Milwaukee',
        'милуоки': 'Milwaukee',
        'милвоки': 'Milwaukee',
        
        # Интерскол
        'интерскол': 'Интерскол',
        'интер': 'Интерскол',
        'intersk': 'Интерскол',
        
        # AEG
        'aeg': 'AEG',
        'аег': 'AEG',
        
        # Festool
        'festool': 'Festool',
        'фестул': 'Festool',
        
        # Hilti
        'hilti': 'Hilti',
        'хилти': 'Hilti'
    }
    
    # Очищаем имя файла от расширения и приводим к нижнему регистру
    clean_name = os.path.splitext(os.path.basename(filename))[0].lower()
    
    # Проверяем имя файла на совпадение с известными брендами
    for brand_key, brand_name in known_brands.items():
        if brand_key in clean_name:
            return brand_name
    
    # Проверяем путь к файлу
    path = os.path.dirname(filename).lower()
    for brand_key, brand_name in known_brands.items():
        if brand_key in path:
            return brand_name
    
    # Если бренд не найден, возвращаем "Неопределённый бренд"
    return "Неизвестный"

def update_image_index(folder_path):
    """Обновление индекса изображений с использованием CLIP"""
    global faiss_index, label_encoder
    
    try:
        features_list = []
        paths_list = []
        
        # Собираем все изображения
        image_files = list(Path(folder_path).glob('*.jpg')) + \
                      list(Path(folder_path).glob('*.jpeg')) + \
                      list(Path(folder_path).glob('*.png'))
        
        logger.info(f"Найдено {len(image_files)} изображений для индексации CLIP")
        
        # Индексируем каждое изображение
        for idx, img_path in enumerate(image_files):
            if idx % 5 == 0:
                logger.info(f"Обработано {idx}/{len(image_files)} изображений")
                
            features = extract_features(str(img_path))
            if features is not None:
                features_list.append(features)
                paths_list.append(str(img_path))
                
                # Брендирование по имени файла для логирования
                brand = detect_brand_from_filename(str(img_path))
                if brand != "Неизвестный":
                    logger.info(f"Добавлено изображение бренда {brand}: {os.path.basename(str(img_path))}")
        
        # Обновляем индекс
        if features_list:
            features_array = np.array(features_list).astype('float32')
            
            # Создаем новый индекс
            feature_dim = features_array.shape[1]
            new_index = faiss.IndexFlatL2(feature_dim)
            new_index.add(features_array)
            
            faiss_index = new_index
            label_encoder = paths_list
            
            # Сохраняем индекс
            with open('clip_image_search_index.pkl', 'wb') as f:
                pickle.dump({
                    'index': faiss_index,
                    'labels': label_encoder
                }, f)
            
            logger.info(f"✅ Индекс CLIP обновлен, добавлено {len(features_list)} изображений")
            return True
        else:
            logger.error("Не удалось извлечь CLIP признаки ни из одного изображения")
            return False
            
    except Exception as e:
        logger.error(f"❌ Ошибка при обновлении индекса CLIP: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return False

def find_similar_images(query_image_path, folder_path=None, top_n=5, similarity_threshold=0.25):
    """Поиск похожих изображений с использованием CLIP и улучшенной коррекцией по типу инструмента и бренду"""
    try:
        # Проверяем инициализацию моделей
        if clip_model is None:
            if not initialize_image_search():
                return []
        
        # Проверяем наличие индекса
        if faiss_index is None or faiss_index.ntotal == 0:
            logger.error("Индекс CLIP не инициализирован или пуст")
            return []
                
        # Извлекаем признаки из запроса
        query_features = extract_features(query_image_path)
        if query_features is None:
            logger.error("Не удалось извлечь CLIP признаки из изображения запроса")
            return []
        
        # Определяем бренд по изображению и имени файла
        query_brand = detect_brand_by_color(query_image_path)
        logger.info(f"Определенный бренд запроса по цветам: {query_brand}")
        
        filename_brand = detect_brand_from_filename(query_image_path)
        if filename_brand != "Неизвестный" and query_brand is None:
            query_brand = filename_brand
            logger.info(f"Бренд определен по имени файла: {query_brand}")
        
        # Определяем тип инструмента
        tool_type, tool_type_ru, tool_confidence = classify_tool_type(query_image_path)
        logger.info(f"Определен тип инструмента: {tool_type_ru} с уверенностью {tool_confidence:.2f}")
        
        # Создаем составное текстовое описание для CLIP, объединяющее бренд и тип инструмента
        if query_brand and tool_type != "unknown":
            composite_description = f"{tool_type} by {query_brand} brand"
            logger.info(f"Составное описание: {composite_description}")
        elif query_brand:
            composite_description = f"power tool by {query_brand} brand"
            logger.info(f"Составное описание только с брендом: {composite_description}")
        elif tool_type != "unknown":
            composite_description = f"{tool_type}"
            logger.info(f"Составное описание только с типом: {composite_description}")
        else:
            composite_description = "power tool"
            logger.info(f"Общее описание: {composite_description}")
        
        # Бренд-специфичные описания с учетом типа инструмента
        brand_specific_prompts = {
            "Makita": {
                "power drill": "blue Makita power drill with black chuck",
                "screwdriver": "blue Makita cordless screwdriver with black handle",
                "hammer drill": "blue Makita hammer drill with SDS chuck",
                "angle grinder": "blue Makita angle grinder with protective guard"
            },
            "Dexter": {
                "power drill": "dark blue Dexter power drill with black chuck",
                "screwdriver": "dark blue Dexter cordless screwdriver with black handle",
                "hammer drill": "dark blue Dexter hammer drill with SDS chuck",
                "angle grinder": "dark blue Dexter angle grinder with protective guard"
            },
            "DeWalt": {
                "power drill": "yellow DeWalt power drill with black chuck",
                "screwdriver": "yellow DeWalt cordless screwdriver with black handle",
                "hammer drill": "yellow DeWalt hammer drill with SDS chuck",
                "angle grinder": "yellow DeWalt angle grinder with protective guard"
            }
        }
        
        # Если есть подходящий специфический промпт для данного бренда и типа инструмента, используем его
        if query_brand in brand_specific_prompts and tool_type in brand_specific_prompts[query_brand]:
            specific_prompt = brand_specific_prompts[query_brand][tool_type]
            logger.info(f"Используем специфичный промпт: {specific_prompt}")
        
        # Ищем похожие изображения по расстоянию косинуса
        query_features = query_features.astype('float32').reshape(1, -1)
        distances, indices = faiss_index.search(
            query_features,
            min(top_n * 4, faiss_index.ntotal)  # Берем больше результатов для фильтрации
        )
        
        # Готовим результаты с улучшенной коррекцией по типу инструмента и бренду
        results = []
        processed_brands = set()  # Для отслеживания уже обработанных брендов
        
        for i, (dist, idx) in enumerate(zip(distances[0], indices[0])):
            if idx < len(label_encoder):
                image_path = label_encoder[idx]
                
                # Базовая схожесть (обратно пропорциональна расстоянию)
                similarity = 1.0 / (1.0 + dist)
                
                # Определяем бренд найденного изображения
                result_brand = detect_brand_by_color(image_path)
                
                # Если не удалось определить по цвету, пробуем по имени файла
                if result_brand is None:
                    result_brand = detect_brand_from_filename(image_path)
                    if result_brand == "Неизвестный":
                        result_brand = None
                
                # Определяем тип инструмента для результата
                result_tool_type, result_tool_type_ru, result_tool_confidence = classify_tool_type(image_path)
                
                logger.info(f"Изображение {os.path.basename(image_path)}: "
                           f"бренд {result_brand}, тип {result_tool_type_ru}, "
                           f"схожесть {similarity:.3f}")
                
                # Корректируем схожесть в зависимости от бренда и типа инструмента
                if similarity >= similarity_threshold:
                    brand_tool_adjusted_similarity = similarity
                    
                    # Корректировка по совпадению типа инструмента (приоритет #1)
                    if tool_type == result_tool_type and tool_type != "unknown":
                        # Если типы инструментов совпадают - сильно повышаем схожесть
                        brand_tool_adjusted_similarity = similarity * 5.0
                        logger.info(f"Корректировка за совпадение типа {tool_type_ru}: {brand_tool_adjusted_similarity:.3f}")
                    elif tool_type != "unknown" and result_tool_type != "unknown" and tool_type != result_tool_type:
                        # Если типы разные - сильно снижаем схожесть
                        brand_tool_adjusted_similarity = similarity * 0.1
                        logger.info(f"Корректировка за разные типы {tool_type_ru}/{result_tool_type_ru}: {brand_tool_adjusted_similarity:.3f}")
                    
                    # Дополнительная корректировка по совпадению бренда (приоритет #2)
                    if query_brand and result_brand == query_brand:
                        # Если бренды совпадают - дополнительно повышаем схожесть
                        brand_tool_adjusted_similarity *= 2.0
                        logger.info(f"Корректировка за совпадение бренда {query_brand}: {brand_tool_adjusted_similarity:.3f}")
                    elif query_brand and result_brand and query_brand != result_brand:
                        # Разные бренды - дополнительно снижаем схожесть
                        brand_tool_adjusted_similarity *= 0.3
                        logger.info(f"Корректировка за разные бренды {query_brand}/{result_brand}: {brand_tool_adjusted_similarity:.3f}")
                    
                    # Ограничиваем значение схожести до 1.0 (100%)
                    brand_tool_adjusted_similarity = min(brand_tool_adjusted_similarity, 1.0)
                    
                    # Добавляем в результаты с информацией о бренде и типе инструмента
                    results.append((
                        image_path, 
                        brand_tool_adjusted_similarity, 
                        result_brand, 
                        result_tool_type_ru
                    ))
                    
                    # Отмечаем бренд как обработанный
                    if result_brand is not None:
                        processed_brands.add(result_brand)
        
        # Сортируем по скорректированной схожести
        results = sorted(results, key=lambda x: x[1], reverse=True)
        
        # Берем топ-N результатов
        top_results = []
        for img_path, sim, brand, tool_type in results[:top_n]:
            top_results.append((img_path, sim))
            logger.info(f"Выбрано в топ результатов: {os.path.basename(img_path)}, "
                      f"бренд: {brand}, тип: {tool_type}, "
                      f"скорректированная схожесть: {sim:.3f}")
        
        return top_results
        
    except Exception as e:
        logger.error(f"Ошибка при поиске изображений с CLIP: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return []

def detect_brand_by_color(image_path):
    """Определяет бренд инструмента по характерным цветам и логотипам"""
    try:
        # Загружаем изображение
        img = cv2.imread(str(image_path))
        if img is None:
            return None
            
        # Преобразуем в HSV
        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        
        # Размеры изображения
        height, width = img.shape[:2]
        total_pixels = height * width
        
        # Цветовые диапазоны для брендов
        # Makita - бирюзовый/синий - расширяем диапазон для лучшего распознавания
        lower_makita = np.array([75, 40, 60])  # Еще больше расширяем диапазон для лучшего обнаружения Makita
        upper_makita = np.array([130, 255, 255])
        makita_mask = cv2.inRange(hsv, lower_makita, upper_makita)
        makita_pixels = cv2.countNonZero(makita_mask)
        
        # Проверяем процент синего цвета для Makita
        makita_percentage = (makita_pixels / total_pixels) * 100
        
        # Если более 8% изображения имеет синий цвет Makita, определяем как Makita
        # Это намного важнее самого контура логотипа
        if makita_percentage > 8:
            logger.info(f"Определен бренд Makita по проценту синего цвета: {makita_percentage:.1f}%")
            return "Makita"
        
        # Интерскол - светло-бирюзовый (более светлый чем Makita)
        lower_interskol = np.array([80, 30, 130])
        upper_interskol = np.array([100, 80, 255])
        interskol_mask = cv2.inRange(hsv, lower_interskol, upper_interskol)
        
        # Dexter - более насыщенный синий
        lower_dexter = np.array([110, 170, 120])  # Увеличиваем насыщенность для разделения с Makita
        upper_dexter = np.array([130, 255, 255])
        dexter_mask = cv2.inRange(hsv, lower_dexter, upper_dexter)
        
        # DeWalt - желтый
        lower_dewalt = np.array([20, 100, 100])
        upper_dewalt = np.array([30, 255, 255])
        dewalt_mask = cv2.inRange(hsv, lower_dewalt, upper_dewalt)
        
        # Milwaukee - красный
        lower_red1 = np.array([0, 120, 120])
        upper_red1 = np.array([10, 255, 255])
        lower_red2 = np.array([170, 120, 120])
        upper_red2 = np.array([180, 255, 255])
        mask_red1 = cv2.inRange(hsv, lower_red1, upper_red1)
        mask_red2 = cv2.inRange(hsv, lower_red2, upper_red2)
        milwaukee_mask = cv2.bitwise_or(mask_red1, mask_red2)
        
        # Bosch (зеленый)
        lower_bosch = np.array([40, 100, 100])
        upper_bosch = np.array([70, 255, 255])
        bosch_mask = cv2.inRange(hsv, lower_bosch, upper_bosch)
        
        # Oasis (ярко-зеленый)
        lower_oasis = np.array([35, 150, 100])
        upper_oasis = np.array([75, 255, 255])
        oasis_mask = cv2.inRange(hsv, lower_oasis, upper_oasis)
        
        # Определяем количество пикселей каждого бренда
        interskol_pixels = cv2.countNonZero(interskol_mask)
        dexter_pixels = cv2.countNonZero(dexter_mask)
        dewalt_pixels = cv2.countNonZero(dewalt_mask)
        milwaukee_pixels = cv2.countNonZero(milwaukee_mask)
        bosch_pixels = cv2.countNonZero(bosch_mask)
        oasis_pixels = cv2.countNonZero(oasis_mask)
        
        # Определяем пороговые значения
        min_pixels = 300  # Снижаем порог для улучшения детекции
        
        # Пропорции изображения
        height, width = img.shape[:2]
        total_pixels = height * width
        
        # Преобразуем для поиска логотипов
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        _, thresh = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY_INV)
        
        # Создаем специальную маску для верхней части (обычное место для логотипов)
        top_mask = np.zeros_like(gray)
        top_mask[:height//3, :] = 255
        top_part = cv2.bitwise_and(thresh, top_mask)
        
        # Находим контуры в верхней части
        contours, _ = cv2.findContours(top_part, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        # Выбираем контуры подходящего размера (потенциальные логотипы)
        potential_logos = []
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area > 100 and area < total_pixels / 10:  # Исключаем очень маленькие и очень большие
                x, y, w, h = cv2.boundingRect(cnt)
                aspect_ratio = float(w) / h if h > 0 else 0
                if 0.5 <= aspect_ratio <= 5.0:  # Логотипы обычно имеют определенные пропорции
                    potential_logos.append(cnt)
        
        # Процент пикселей от общего количества для определения доминирующего цвета
        color_threshold_percent = 0.5  # 0.5%
        color_threshold = total_pixels * color_threshold_percent / 100
        
        # Логируем для отладки
        logger.info(f"Распознавание бренда для {os.path.basename(image_path)}")
        logger.info(f"Пиксели брендов: Makita: {makita_pixels}, Dexter: {dexter_pixels}, " +
                   f"Milwaukee: {milwaukee_pixels}, DeWalt: {dewalt_pixels}, " +
                   f"Интерскол: {interskol_pixels}, Bosch: {bosch_pixels}, " +
                   f"Oasis: {oasis_pixels}")
        logger.info(f"Найдено потенциальных логотипов: {len(potential_logos)}")
        
        # Для Oasis/зеленой дрели проверяем наличие зеленого цвета и логотипа
        if oasis_pixels > min_pixels * 3:  # Требуем больше зеленых пикселей для уверенности
            # Проверяем наличие логотипа в верхней части
            has_logo_in_top = False
            for cnt in potential_logos:
                x, y, w, h = cv2.boundingRect(cnt)
                if y < height // 3:  # Только в верхней трети
                    has_logo_in_top = True
                    break
            
            # Если есть достаточно зеленого цвета и логотип в верхней части
            if has_logo_in_top or oasis_pixels > color_threshold * 8:
                logger.info(f"Определен бренд Oasis по зеленому цвету: {oasis_pixels} пикселей")
                return "Oasis"
        
        # Для Makita ищем характерный логотип (буквы "MAKITA") и цвет
        if makita_pixels > min_pixels:
            # Если есть значительное количество синего и потенциальные логотипы
            if makita_pixels > dexter_pixels and makita_pixels > interskol_pixels:
                # Проверяем, похожи ли контуры на буквы
                letter_contours = 0
                for cnt in potential_logos:
                    x, y, w, h = cv2.boundingRect(cnt)
                    # Анализируем пропорции контуров для букв
                    if 0.2 < w/h < 1.5 and 10 < w < 60 and 10 < h < 60:
                        letter_contours += 1
                
                # Если найдено достаточно контуров похожих на буквы в сочетании с цветом
                if letter_contours >= 2 or makita_pixels > color_threshold * 5:
                    return "Makita"
        
        # Для Dexter анализируем более строго пропорции логотипа
        if dexter_pixels > min_pixels:
            # Если синий Dexter доминирует над другими оттенками синего
            if dexter_pixels > makita_pixels and dexter_pixels > interskol_pixels:
                # Ищем характерные прямоугольные формы логотипа Dexter
                rect_like_contours = 0
                for cnt in potential_logos:
                    x, y, w, h = cv2.boundingRect(cnt)
                    # Dexter логотип более прямоугольный
                    if 3 < w < 100 and 3 < h < 50 and w > h * 1.5:
                        rect_like_contours += 1
                
                # Учитываем как цвет, так и форму контуров
                if rect_like_contours >= 1 or dexter_pixels > color_threshold * 5:
                    return "Dexter"
        
        # Проверка на Интерскол - если есть характерный светло-бирюзовый цвет
        if interskol_pixels > min_pixels:
            if interskol_pixels > makita_pixels * 0.8:
                # Дополнительный анализ контуров для Интерскол
                for cnt in potential_logos:
                    x, y, w, h = cv2.boundingRect(cnt)
                    # Логотип Интерскол обычно имеет характерные пропорции
                    if 1.5 < w/h < 5.0 and h < 40:
                        return "Интерскол"
                
                # Если контуры не найдены, но цвет явно преобладает
                if interskol_pixels > color_threshold * 4:
                    return "Интерскол"
        
        # Для DeWalt - яркий желтый цвет и характерный логотип
        if dewalt_pixels > min_pixels:
            # Если много желтого цвета
            if dewalt_pixels > color_threshold * 3:
                # Проверяем наличие прямоугольных желтых областей
                yellow_areas = 0
                yellow_contours, _ = cv2.findContours(dewalt_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                for cnt in yellow_contours:
                    area = cv2.contourArea(cnt)
                    if area > 200:  # Достаточно большая желтая область
                        yellow_areas += 1
                
                if yellow_areas > 0 or dewalt_pixels > color_threshold * 6:
                    return "DeWalt"
        
        # Для Milwaukee - красный цвет
        if milwaukee_pixels > min_pixels:
            if milwaukee_pixels > color_threshold * 4:
                return "Milwaukee"
                
        # Для Bosch - зеленый цвет
        if bosch_pixels > min_pixels:
            if bosch_pixels > color_threshold * 4:
                return "Bosch"
        
        # Если большое количество зеленого цвета и нет четкого определения
        if oasis_pixels > min_pixels * 2:
            if oasis_pixels > bosch_pixels:
                logger.info(f"Определен бренд Oasis по преобладанию зеленого: {oasis_pixels} пикселей")
                return "Oasis"
        
        # Если большое количество синего, но нет четкого определения между Makita и Dexter и Интерскол
        # Используем соотношение между ними для определения
        if makita_pixels > min_pixels * 2:
            if makita_pixels > dexter_pixels * 2 and makita_pixels > interskol_pixels * 2:
                return "Makita"
        
        if dexter_pixels > min_pixels * 2:
            if dexter_pixels > makita_pixels * 2 and dexter_pixels > interskol_pixels * 2:
                return "Dexter"
        
        if interskol_pixels > min_pixels * 2:
            if interskol_pixels > makita_pixels * 1.5 and interskol_pixels > dexter_pixels * 1.5:
                return "Интерскол"
        
        # Если не удалось определить бренд однозначно
        logger.info(f"Не удалось однозначно определить бренд для {os.path.basename(image_path)}")
        return None
        
    except Exception as e:
        logger.error(f"Ошибка при определении бренда по цвету: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return None

def classify_tool_type(image_path, clip_text_features=None):
    """Определяет тип инструмента на изображении с использованием CLIP"""
    try:
        # Типы инструментов для классификации
        tool_types = [
            "power drill", 
            "cordless drill",
            "cordless screwdriver",
            "screwdriver", 
            "impact driver",
            "hammer drill",
            "angle grinder", 
            "circular saw",
            "jigsaw",
            "miter saw",
            "rotary tool"
        ]
        
        # Русские эквиваленты для логирования и вывода
        tool_types_ru = {
            "power drill": "Дрель", 
            "cordless drill": "Аккумуляторная дрель",
            "screwdriver": "Шуруповерт",
            "cordless screwdriver": "Аккумуляторный шуруповерт",
            "impact driver": "Ударный гайковерт",
            "hammer drill": "Перфоратор",
            "angle grinder": "Угловая шлифмашина", 
            "circular saw": "Циркулярная пила",
            "jigsaw": "Электролобзик",
            "miter saw": "Торцовочная пила",
            "rotary tool": "Многофункциональный инструмент"
        }
        
        # Усиливаем описания для лучшего распознавания
        enhanced_prompts = [
            "a power drill with visible chuck and motor",
            "a cordless battery-powered drill with black chuck",
            "a cordless screwdriver with battery pack and plastic housing",
            "a screwdriver with bit holder and trigger",
            "an impact driver with square drive head",
            "a hammer drill with SDS chuck and drill bits",
            "an angle grinder with cutting disc and guard",
            "a circular saw with round blade and base plate",
            "a jigsaw with thin vertical blade",
            "a miter saw with large circular blade and base",
            "a rotary tool with small head and various accessories"
        ]
        
        # Получаем изображение
        image = Image.open(image_path).convert('RGB')
        
        # Если модель CLIP не загружена, загружаем
        global clip_model, clip_processor
        if clip_model is None:
            initialize_image_search()
        
        with torch.no_grad():
            # Обрабатываем изображение
            if isinstance(clip_processor, CLIPProcessor):
                # Для трансформеров
                inputs = clip_processor(images=image, return_tensors="pt")
                image_features = clip_model.get_image_features(**inputs)
                
                # Обрабатываем текстовые промпты
                text_inputs = clip_processor(text=enhanced_prompts, return_tensors="pt", padding=True)
                text_features = clip_model.get_text_features(**text_inputs)
                
                # Нормализуем векторы
                image_features = image_features / image_features.norm(dim=1, keepdim=True)
                text_features = text_features / text_features.norm(dim=1, keepdim=True)
                
                # Считаем сходство
                similarity = (100.0 * image_features @ text_features.T).softmax(dim=1)
                similarity = similarity.cpu().numpy()[0]
            else:
                # Для оригинальной библиотеки CLIP
                image_tensor = clip_processor(image).unsqueeze(0).to(clip_device)
                text_tensor = clip.tokenize(enhanced_prompts).to(clip_device)
                
                # Получаем эмбеддинги
                image_features = clip_model.encode_image(image_tensor)
                text_features = clip_model.encode_text(text_tensor)
                
                # Нормализуем векторы
                image_features = image_features / image_features.norm(dim=1, keepdim=True)
                text_features = text_features / text_features.norm(dim=1, keepdim=True)
                
                # Считаем сходство
                similarity = (100.0 * (image_features @ text_features.T)).softmax(dim=1)
                similarity = similarity.cpu().numpy()[0]
            
            # Определяем лучший тип инструмента
            best_match_idx = np.argmax(similarity)
            best_match = tool_types[best_match_idx]
            confidence = similarity[best_match_idx]
            
            # Получаем русское название
            tool_type_ru = tool_types_ru.get(best_match, best_match)
            
            logger.info(f"Классификация инструмента: {tool_type_ru} ({best_match}) с уверенностью {confidence:.2f}")
            
            # Для отладки выводим все классы с вероятностями
            for i, tool in enumerate(tool_types):
                logger.info(f"  - {tool_types_ru.get(tool, tool)}: {similarity[i]:.4f}")
            
            return best_match, tool_type_ru, confidence
            
    except Exception as e:
        logger.error(f"Ошибка при классификации типа инструмента: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return "unknown", "Неизвестный инструмент", 0.0

async def photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для фотографий с обнаружением нескольких инструментов"""
    if not context.user_data.get("awaiting_photo", False):
        await update.message.reply_text("⚠️ Для поиска по фото сначала выберите 'Поиск по фото' в меню и выберите отдел.")
        return

    # Получаем выбранный отдел (если есть)
    selected_department = context.user_data.get("selected_department", "")
    department_emoji = selected_department.split()[0] if selected_department else "📸"

    # Отправляем сообщение о начале обработки
    processing_message = await update.message.reply_text(
        f"{department_emoji} Начинаю обработку фотографии...\n"
        "Это может занять некоторое время."
    )

    # Временные файлы для отслеживания и последующего удаления
    temp_files = []

    try:
        # После получения фотографии отключаем режим
        context.user_data["awaiting_photo"] = False

        config = load_config()
        photos_folder = config.get("photos_folder")

        # Проверяем существование папки с фотографиями (для локального поиска)
        if not photos_folder or not os.path.exists(photos_folder):
            logger.warning(f"Папка с фотографиями не найдена: {photos_folder}")
        
        # Создаем временную папку, если её нет
        os.makedirs("temp", exist_ok=True)

        # Сохраняем фотографию, отправленную пользователем
        photo_file = await update.message.photo[-1].get_file()
        user_photo_path = os.path.join("temp", f"{photo_file.file_id}.jpg")
        temp_files.append(user_photo_path)

        await photo_file.download_to_drive(user_photo_path)
        logger.info(f"Фото сохранено во временный файл: {user_photo_path}")
        
        # Обновляем сообщение о статусе
        await processing_message.edit_text(
            f"{department_emoji} Фотография получена и сохранена.\n"
            "Анализирую изображение и ищу инструменты..."
        )

        # Применяем предобработку изображения
        enhanced_photo_path = preprocess_image_for_search(user_photo_path)
        if enhanced_photo_path:
            logger.info(f"Использую улучшенное изображение для поиска: {enhanced_photo_path}")
            search_photo_path = enhanced_photo_path
            temp_files.append(enhanced_photo_path)
        else:
            logger.warning("Не удалось улучшить изображение, использую оригинал")
            search_photo_path = user_photo_path
        
        # Инициализируем модели если нужно
        if clip_model is None:
            await processing_message.edit_text(
                f"{department_emoji} Инициализация системы поиска...\n"
                "Первый запуск может занять больше времени."
            )
            if not initialize_image_search():
                await update.message.reply_text(
                    "❌ Не удалось инициализировать систему поиска.\n"
                    "Пожалуйста, попробуйте позже или обратитесь к администратору."
                )
                return

        # Обновляем индекс если нужно
        if faiss_index is None or faiss_index.ntotal == 0:
            if not photos_folder or not os.path.exists(photos_folder):
                await update.message.reply_text(
                    "❌ Папка с базой изображений не найдена.\n"
                    "Пожалуйста, обратитесь к администратору."
                )
                return
                
            await processing_message.edit_text( 
                f"{department_emoji} Создание индекса изображений...\n"
                "Это может занять несколько минут при первом запуске."
            )
            if not update_image_index(photos_folder):
                await update.message.reply_text(
                    "❌ Не удалось создать индекс изображений.\n"
                    "Пожалуйста, попробуйте позже или обратитесь к администратору."
                )
                return
        
        # Обнаруживаем инструменты на изображении
        await processing_message.edit_text(
            f"{department_emoji} Обнаружение инструментов на изображении...\n"
            "Анализирую фотографию..."
        )
        
        detected_tools = detect_tools_on_image(search_photo_path)
        
        # Если нашли несколько инструментов
        if len(detected_tools) > 1:
            logger.info(f"Обнаружено {len(detected_tools)} инструментов на изображении")
            await processing_message.edit_text(
                f"{department_emoji} Обнаружено {len(detected_tools)} объектов на изображении.\n"
                "Ищу похожие товары для каждого объекта..."
            )
            
            # Обрабатываем каждый инструмент по отдельности
            all_results = []
            
            for i, tool in enumerate(detected_tools):
                # Извлекаем изображение инструмента
                tool_image_path = extract_tool_by_bbox(search_photo_path, tool['bbox'])
                if tool_image_path:
                    temp_files.append(tool_image_path)
                    
                    # Ищем похожие изображения для этого инструмента
                    similar_images = find_similar_images(tool_image_path, top_n=3, similarity_threshold=0.25)
                    
                    if similar_images:
                        # Классифицируем тип инструмента
                        tool_type, tool_type_ru, _ = classify_tool_type(tool_image_path)
                        
                        # Добавляем результаты с информацией об инструменте
                        all_results.append({
                            'tool_image': tool_image_path,
                            'similar_images': similar_images,
                            'tool_type': tool_type_ru,
                            'confidence': tool['confidence'],
                            'class_name': tool['class_name']
                        })
            
            # Удаляем сообщение о статусе поиска
            await processing_message.delete()
            
            # Если нашли результаты хотя бы для одного инструмента
            if all_results:
                await update.message.reply_text(
                    f"{department_emoji} *Обнаружено {len(all_results)} инструментов на изображении*\n"
                    f"Показываю результаты поиска для каждого инструмента:",
                    parse_mode='Markdown'
                )
                
                # Отправляем результаты для каждого инструмента
                for i, result in enumerate(all_results):
                    # Отправляем изображение вырезанного инструмента
                    await update.message.reply_photo(
                        open(result['tool_image'], 'rb'),
                        caption=f"🔍 Инструмент #{i+1}\n"  # Убираем тип инструмента из описания
                               f"Найдено похожих товаров: {len(result['similar_images'])}",
                        parse_mode='Markdown'
                    )
                    
                    # Отправляем похожие изображения для этого инструмента
                    for j, (image_path, similarity_score) in enumerate(result['similar_images']):
                        try:
                            with open(image_path, "rb") as file:
                                similarity_percent = min(similarity_score * 100, 100)
                                await update.message.reply_photo(
                                    file, 
                                    caption=f"📌 Результат #{j+1} для инструмента #{i+1}\n"
                                           f"Схожесть: {similarity_percent:.0f}%"
                                )
                        except Exception as e:
                            logger.error(f"Ошибка при отправке изображения {image_path}: {e}")
                
                # Добавляем кнопку для возврата к выбору отдела
                keyboard = [["🔙 Назад к выбору отдела"], ["🔙 Назад в меню"]]
                reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
                
                await update.message.reply_text(
                    "Хотите продолжить поиск в другом отделе или с другой фотографией?",
                    reply_markup=reply_markup
                )
            else:
                # Создаем клавиатуру с кнопками навигации
                keyboard = [["🔙 Назад к выбору отдела"], ["🔙 Назад в меню"]]
                reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
                
                await update.message.reply_text(
                    f"{department_emoji} *Не удалось найти похожие товары для обнаруженных инструментов*\n\n"
                    "Пожалуйста, попробуйте сделать более четкие фотографии отдельных инструментов.",
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
        else:
            # Если нашли только один инструмент или не нашли ни одного, используем общий поиск
            await processing_message.edit_text(
                f"{department_emoji} Поиск похожих товаров...\n"
                f"Сравниваю с базой товаров в отделе {selected_department if selected_department else 'товаров'}."
            )
            
            # Используем стандартный поиск или улучшенный в зависимости от настройки
            if use_enhanced_search:
                similar_images = enhanced_image_search(search_photo_path, top_n=5, similarity_threshold=0.25)
                logger.info("Используется улучшенный поиск изображений")
            else:
                similar_images = find_similar_images(search_photo_path, top_n=5, similarity_threshold=0.25)
                logger.info("Используется базовый поиск изображений")
                
            logger.info(f"Найдено похожих изображений: {len(similar_images) if similar_images else 0}")
            
            # Удаляем сообщение о статусе поиска
            await processing_message.delete()
            
            if similar_images:
                # Определяем тип инструмента для отображения
                tool_type, tool_type_ru, _ = classify_tool_type(search_photo_path)
                
                # Определяем бренд запроса для использования при корректировке схожести
                query_brand = detect_brand_by_color(search_photo_path)
                if query_brand is None:
                    query_brand = detect_brand_from_filename(search_photo_path)
                    if query_brand == "Неизвестный":
                        query_brand = None
                        
                logger.info(f"Запрос: определен тип инструмента {tool_type_ru}, бренд {query_brand}")
                
                result_text = f"{department_emoji} *Найдено {len(similar_images)} похожих товаров*\n"
                if selected_department:
                    result_text += f"В отделе: *{selected_department}*\n"
                result_text += "Результаты отсортированы по степени схожести:"
                
                await update.message.reply_text(
                    result_text,
                    parse_mode='Markdown'
                )
                
                # Отправляем результаты
                for idx, (image_path, similarity_score) in enumerate(similar_images, start=1):
                    try:
                        with open(image_path, "rb") as file:
                            # Определяем бренд только для логирования
                            result_brand = detect_brand_by_color(image_path)
                            if result_brand is None:
                                result_brand = detect_brand_from_filename(image_path)
                                if result_brand == "Неизвестный":
                                    result_brand = None
                            
                            if result_brand:
                                logger.info(f"Результат #{idx}: определен бренд (не отображается): {result_brand}")
                            
                            # Определяем тип результата
                            result_type, result_type_ru, _ = classify_tool_type(image_path)
                            
                            caption = f"{department_emoji} Результат #{idx}\n"
                            
                            # Применяем нелинейную шкалу для отображения процента схожести
                            # Это позволит повысить значения для реальных совпадений
                            # и сохранить низкие значения для плохих совпадений
                            
                            # Для первого результата всегда показываем высокую схожесть
                            if idx == 1 and similarity_score > 0.3:
                                display_similarity = 100
                            else:
                                # Нелинейное масштабирование для повышения значений
                                enhanced_similarity = similarity_score ** 0.5  # Корень квадратный
                                display_similarity = min(enhanced_similarity * 100, 100)
                                
                                # Если это Makita vs Makita или другое точное совпадение бренда и типа
                                if result_brand and result_brand == query_brand and result_type == tool_type:
                                    display_similarity = max(display_similarity, 85)  # Минимум 85% для точных совпадений
                            
                            caption += f"Схожесть: {display_similarity:.0f}%"
                            
                            await update.message.reply_photo(
                                file, 
                                caption=caption
                            )
                    except Exception as e:
                        logger.error(f"Ошибка при отправке изображения {image_path}: {e}")
                        await update.message.reply_text(
                            f"⚠️ Не удалось отправить изображение #{idx}"
                        )
                
                # Добавляем кнопку для возврата к выбору отдела
                keyboard = [["🔙 Назад к выбору отдела"], ["🔙 Назад в меню"]]
                reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
                
                await update.message.reply_text(
                    "Хотите продолжить поиск в другом отделе или с другой фотографией?",
                    reply_markup=reply_markup
                )
            else:
                # Создаем клавиатуру с кнопками навигации
                keyboard = [["🔙 Назад к выбору отдела"], ["🔙 Назад в меню"]]
                reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
                
                await update.message.reply_text(
                    f"{department_emoji} *Похожие товары не найдены*\n\n"
                    "Рекомендации:\n"
                    "• Попробуйте сделать другую фотографию\n"
                    "• Улучшите освещение\n"
                    "• Попробуйте выбрать другой отдел\n"
                    "• Убедитесь, что товар хорошо виден",
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )

    except Exception as e:
        logger.error(f"Ошибка при обработке фотографии: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        
        # Удаляем сообщение о процессе если оно есть
        try:
            await processing_message.delete()
        except:
            pass
            
        # Создаем клавиатуру для возврата
        keyboard = [["🔙 Назад к выбору отдела"], ["🔙 Назад в меню"]]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
            
        await update.message.reply_text(
            "⚠️ Произошла ошибка при обработке фотографии.\n"
            "Технические детали были записаны в журнал.\n\n"
            "Пожалуйста, попробуйте еще раз или обратитесь к администратору.",
            reply_markup=reply_markup
        )

    finally:
        # Удаляем временные файлы
        try:
            for file_path in temp_files:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    logger.info(f"Временный файл удален: {file_path}")
        except Exception as e:
            logger.error(f"Ошибка при удалении временных файлов: {e}")

async def search_in_colors(query: str, excel_file: str, context) -> list:
    """
    Поиск в базе цветов по колонке 'Цвет'
    """
    try:
        # Читаем Excel файл
        df = pd.read_excel(excel_file)
        logger.info(f"Загружена таблица цветов. Количество строк: {len(df)}")
        logger.info(f"Колонки в таблице: {df.columns.tolist()}")
        
        # Проверяем наличие колонки 'Цвет'
        if 'Цвет' not in df.columns:
            logger.error("❌ В таблице отсутствует колонка 'Цвет'")
            return ["❌ Ошибка в структуре таблицы"]

        # Удаляем пробелы из запроса и приводим к нижнему регистру
        query = query.lower().strip()
        logger.info(f"Поисковый запрос: {query}")

        # Поиск в колонке 'Цвет'
        mask = df['Цвет'].astype(str).str.lower().str.contains(query, na=False)
        matches = df[mask]
        
        logger.info(f"Найдено совпадений: {len(matches)}")
        
        if not matches.empty:
            # Форматируем совпадения
            results = []
            for _, row in matches.iterrows():
                result_parts = []
                for col in df.columns:
                    value = row[col]
                    if col == 'Цвет':
                        result_parts.append(f"🎨 *{value}*")
                    else:
                        if pd.notna(value):  # Проверяем, что значение не NaN
                            # Форматируем числовое значение
                            formatted_value = format_numeric_value(value)
                            result_parts.append(f"• {col}: {formatted_value}")
                
                results.append("\n".join(result_parts))
            return results
        else:
            # Выводим первые несколько строк для отладки
            logger.info("Примеры данных из таблицы:")
            logger.info(df['Цвет'].head().to_string())
            return ["❌ Ничего не найдено. Попробуйте изменить запрос."]
                
    except Exception as e:
        logger.error(f"Ошибка при поиске цветов: {e}")
        return ["❌ Произошла ошибка при поиске"]

async def search_in_stores(query: str, excel_file: str, context) -> list:
    """
    Поиск в базе магазинов по их названию и адресу
    """
    try:
        # Читаем Excel файл
        df = pd.read_excel(excel_file)
        logger.info(f"Загружена таблица магазинов. Количество строк: {len(df)}")
        logger.info(f"Колонки в таблице: {df.columns.tolist()}")
        
        # Проверяем наличие необходимых колонок
        required_columns = ['Название', 'Адрес']
        missing_columns = [col for col in required_columns if col not in df.columns]
        
        if missing_columns:
            logger.error(f"❌ В таблице отсутствуют колонки: {', '.join(missing_columns)}")
            return ["❌ Ошибка в структуре таблицы магазинов"]

        # Приводим запрос к нижнему регистру
        query = query.lower().strip()
        logger.info(f"Поисковый запрос для магазинов: {query}")

        # Поиск по названию и адресу
        matches = df[
            df['Название'].astype(str).str.lower().str.contains(query, na=False) |
            df['Адрес'].astype(str).str.lower().str.contains(query, na=False)
        ]
        
        logger.info(f"Найдено совпадений: {len(matches)}")
        
        if not matches.empty:
            # Форматируем результаты
            results = []
            for _, row in matches.iterrows():
                store_info = [f"🏪 *{row['Название']}*"]
                
                for col in df.columns:
                    if col != 'Название':
                        value = row[col]
                        if pd.notna(value):  # Проверяем, что значение не NaN
                            if col == 'Адрес':
                                store_info.append(f"📍 Адрес: {value}")
                            else:
                                store_info.append(f"• {col}: {value}")
                
                results.append("\n".join(store_info))
            
            return results
        else:
            # Выводим для отладки
            logger.info("Примеры данных из таблицы:")
            logger.info(df[['Название', 'Адрес']].head().to_string())
            return []
                
    except Exception as e:
        logger.error(f"Ошибка при поиске магазинов: {e}")
        return ["❌ Произошла ошибка при поиске магазинов"]

async def search_in_skobyanka(query: str, excel_file: str, context) -> list:
    """
    Поиск в базе скобяных изделий
    """
    try:
        # Проверяем наличие файла
        if not os.path.exists(excel_file):
            logger.error(f"❌ Файл скобянки не найден: {excel_file}")
            return ["❌ Файл с базой данных не найден"]
            
        # Читаем Excel файл
        df = pd.read_excel(excel_file)
        logger.info(f"Загружена таблица скобянки. Количество строк: {len(df)}")
        logger.info(f"Колонки в таблице: {df.columns.tolist()}")
        
        # Удаляем пробелы из запроса и приводим к нижнему регистру
        query = query.lower().strip()
        logger.info(f"Поисковый запрос для скобянки: {query}")

        # Поиск по всем колонкам
        matches = df.apply(
            lambda row: any(
                str(value).lower().find(query) != -1 
                for value in row if pd.notna(value)
            ), 
            axis=1
        )
        
        results_df = df[matches]
        logger.info(f"Найдено совпадений: {len(results_df)}")
        
        if not results_df.empty:
            # Форматируем совпадения
            results = []
            for _, row in results_df.iterrows():
                result_parts = []
                
                # Определяем основное название/артикул
                name_column = next((col for col in ['Наименование', 'Товар', 'Артикул'] if col in df.columns), df.columns[0])
                result_parts.append(f"🔧 *{row[name_column]}*")
                
                # Добавляем остальные поля
                for col in df.columns:
                    if col != name_column:
                        value = row[col]
                        if pd.notna(value):  # Проверяем, что значение не NaN
                            result_parts.append(f"• {col}: {value}")
                
                results.append("\n".join(result_parts))
            
            return results[:10]  # Ограничиваем до 10 результатов
        else:
            return []
                
    except Exception as e:
        logger.error(f"Ошибка при поиске скобянки: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return ["❌ Произошла ошибка при поиске"]

async def colors_base_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела цветов"""
    user_id = update.effective_user.id

    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("colors", user_id)

    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return

    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("colors", user_id)

    keyboard = [
        ["🔙 Назад в товары"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Устанавливаем состояние поиска цветов
    context.user_data['state'] = 'searching_colors'
    
    await update.message.reply_text(
        "*🎨 Поиск в базе цветов*\n\n"
        "Введите название цвета для поиска.\n"
        "Можно искать по:\n"
        "• Названию цвета\n"
        "• Коду цвета\n"
        "• Комбинации слов\n\n"
        "💡 _Пример: серый металлик_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def back_to_contacts_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик возврата в раздел контактов"""
    await contacts_handler(update, context)


async def egais_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для документов ЕГАИС"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return

    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("egais", user_id)

    try:
        # Загружаем конфигурацию
        config = load_config()
        if not config:
            await update.message.reply_text("❌ Ошибка: не удалось загрузить конфигурацию")
            return

        # Получаем путь к файлу
        file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data', 'les_ega.pdf')
        
        if not os.path.exists(file_path):
            await update.message.reply_text("❌ Файл не найден")
            return

        # Отправляем файл
        await update.message.reply_document(
            document=open(file_path, 'rb'),
            filename='les_ega.pdf',
            caption="📄 Документация по ЕГАИС"
        )

    except Exception as e:
        logger.error(f"Ошибка при отправке файла ЕГАИС: {e}")
        await update.message.reply_text("❌ Произошла ошибка при отправке файла")


# Список разрешенных пользователей (whitelist)
whitelist = [2093834331]

async def check_whitelist_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для проверки пользователей в whitelist"""
    user_id = update.effective_user.id
    
    if user_id not in whitelist:
        await update.message.reply_text("⛔ У вас нет доступа к этой команде.")
        return

    if whitelist:
        users = "*Пользователи в whitelist:*\n" + "\n".join([str(user) for user in whitelist])
    else:
        users = "❌ В whitelist нет пользователей."

    await update.message.reply_text(users, parse_mode='Markdown')


async def admin_panel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для админ-панели"""
    user_id = update.effective_user.id
    config = load_config()

    if user_id not in config.get('admins', []):
        await update.message.reply_text(
            "⛔ *Доступ запрещен*\n"
            "У вас нет прав администратора.",
            parse_mode='Markdown'
        )
        return

    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("admin_panel", user_id)

    keyboard = [
        ["👥 Управление пользователями"],
        ["📊 Статистика", "🔄 Обновить базы"],
        ["🔙 Назад в меню"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    await update.message.reply_text(
        "*🛠️ Панель администратора*\n\n"
        "Выберите действие:\n"
        "• 👥 Управление пользователями - добавление/удаление пользователей\n"
        "• 📊 Статистика - просмотр статистики использования бота\n"
        "• 🔄 Обновить базы - обновление баз данных\n\n"
        "💡 _Используйте кнопки для навигации_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )


async def user_management_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик раздела управления пользователями"""
    user_id = update.effective_user.id
    config = load_config()

    if user_id not in config.get('admins', []):
        await update.message.reply_text("⛔ Доступ запрещен")
        return

    keyboard = [
        ["➕ Добавить пользователя", "➖ Удалить пользователя"],
        ["📋 Список пользователей"],
        ["🔙 Назад в админ-панель"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    await update.message.reply_text(
        "*👥 Управление пользователями*\n\n"
        "Выберите действие:\n"
        "• Добавить пользователя\n"
        "• Удалить пользователя\n"
        "• Просмотреть список пользователей",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def remove_user_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик удаления пользователя"""
    user_id = update.effective_user.id
    config = load_config()

    if user_id not in config.get('admins', []):
        await update.message.reply_text("⛔ Доступ запрещен")
        return

    # Устанавливаем состояние ожидания ID пользователя для удаления
    context.user_data['state'] = 'awaiting_remove_user_id'

    await update.message.reply_text(
        "*➖ Удаление пользователя*\n\n"
        "Отправьте ID пользователя, которого хотите удалить.",
        parse_mode='Markdown'
    )

async def add_to_whitelist_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для добавления пользователей в whitelist"""
    user_id = update.effective_user.id
    
    if user_id not in whitelist:
        await update.message.reply_text("⛔ У вас нет доступа к этой команде.")
        return

    if context.args:
        new_user_id = context.args[0]
        if new_user_id not in whitelist:
            whitelist.append(new_user_id)
            await update.message.reply_text(f"✅ Пользователь {new_user_id} добавлен в whitelist.")
        else:
            await update.message.reply_text("❌ Этот пользователь уже в whitelist.")
    else:
        await update.message.reply_text("❌ Пожалуйста, укажите ID пользователя для добавления.")


async def statistics_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для просмотра статистики использования бота"""
    try:
        user_id = update.effective_user.id
        config = load_config()

        if user_id not in config.get('admins', []):
            await update.message.reply_text("⛔ Доступ запрещен")
            return

        # Получаем аналитику из контекста бота
        analytics = context.bot_data.get('analytics')
        if not analytics:
            await update.message.reply_text("❌ Ошибка: система аналитики недоступна")
            return

        # Получаем статистику команд
        command_stats = analytics.get_command_stats()

        # Формируем сообщение со статистикой
        stats_message = "*📊 Статистика использования бота*\n\n"

        # Расширенный словарь для перевода названий команд
        command_names = {
            'start': '🚀 Запуск бота',
            'help': '❓ Помощь',
            'contacts': '📞 Контакты',
            'products': '📦 Товары',
            'documents': '📄 Документы',
            'stores': '🏪 Поиск магазинов',
            'colors': '🎨 Поиск цветов',
            'colors_base': '🎨 База цветов',
            'skobyanka': '🔧 Скобянка',
            'admin_panel': '⚙️ Админ-панель',
            'photo_search': '📸 Поиск по фото',
            'back_to_menu': '🔙 Возврат в меню',
            'add_user': '➕ Добавление пользователя',
            'remove_user': '➖ Удаление пользователя',
            'text_search': '🔍 Текстовый поиск',
            'maps': '🗺️ Карты',
            'logistics': '🚚 Логистика',
            'egais': '📋 ЕГАИС',
            'unknown_command': '❓ Неизвестная команда'
        }

        # Добавляем статистику команд
        if command_stats:
            stats_message += "*Использование команд:*\n"
            for command, count in command_stats:
                friendly_name = command_names.get(command, f"🔹 {command}")  # Добавляем маркер для неизвестных команд
                stats_message += f"• {friendly_name}: {count} раз\n"
        else:
            stats_message += "📝 Пока нет данных об использовании команд\n"

        # Добавляем разделитель
        stats_message += "\n"

        # Добавляем кнопку возврата
        keyboard = [["🔙 Назад в админ-панель"]]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

        # Отправляем сообщение с экранированием специальных символов
        await update.message.reply_text(
            stats_message.replace(".", "\\.").replace("-", "\\-").replace("_", "\\_"),
            parse_mode='MarkdownV2',
            reply_markup=reply_markup
        )

    except Exception as e:
        logger.error(f"Ошибка при получении статистики: {e}")
        await update.message.reply_text(
            "❌ Произошла ошибка при получении статистики\n"
            f"Детали: {str(e)}"
        )

async def add_user_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик добавления пользователя"""
    user_id = update.effective_user.id
    config = load_config()

    if user_id not in config.get('admins', []):
        await update.message.reply_text("⛔ Доступ запрещен")
        return

    # Устанавливаем состояние ожидания ID пользователя
    context.user_data['state'] = 'awaiting_new_user_id'

    await update.message.reply_text(
        "*➕ Добавление пользователя*\n\n"
        "Отправьте ID пользователя, которого хотите добавить.",
        parse_mode='Markdown'
    )


async def list_users_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для просмотра списка пользователей"""
    user_id = update.effective_user.id
    config = load_config()

    if user_id not in config.get('admins', []):
        await update.message.reply_text("⛔ Доступ запрещен")
        return

    whitelist = config.get('whitelist', [])
    admins = config.get('admins', [])

    if not whitelist:
        await update.message.reply_text("❌ В списке нет пользователей.")
        return

    # Формируем сообщение со списком пользователей
    message = "*👥 Список пользователей*\n\n"
    
    for idx, uid in enumerate(whitelist, 1):
        admin_mark = "👑 " if uid in admins else ""
        message += f"{idx}. {admin_mark}ID: `{uid}`\n"

    message += "\n💡 _Администраторы отмечены значком_ 👑"

    await update.message.reply_text(
        message,
        parse_mode='Markdown'
    )


async def back_to_admin_panel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик возврата в админ-панель"""
    await admin_panel_handler(update, context)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик команды /start - показывает главное меню"""
    user_id = update.effective_user.id
    username = update.effective_user.username or "пользователь"
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("start", user_id)
    
    # Проверяем, есть ли пользователь в белом списке
    if not is_allowed_user(user_id):
        await update.message.reply_text(
            f"⛔ <b>Доступ запрещен</b>\n\n"
            f"Ваш ID: <code>{user_id}</code>\n\n"
            f"Для получения доступа обратитесь к администратору.",
            parse_mode='HTML'
        )
        return
    
    # Формируем клавиатуру для главного меню
    keyboard = [
        ["📞 Контакты", "📸 Поиск по фото"],
        # ["📦 Товары", "📄 Документы"], # Временно скрыто
        ["❓ Помощь"]
    ]
    
    # Добавляем кнопку админ-панели для администраторов
    # Убрано: админ-панель теперь доступна только через команду /admin
    # config = load_config()
    # if user_id in config.get('admins', []):
    #     keyboard.append(["⚙️ Админ-панель"])
    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Отправляем приветственное сообщение
    await update.message.reply_text(
        f"👋 Добро пожаловать, {username}!\n\n"
        f"Выберите нужный раздел с помощью кнопок меню:\n"
        f"• 📞 Контакты - информация о магазинах\n"
        # f"• 📦 Товары - каталог товаров\n" # Временно скрыто
        # f"• 📄 Документы - доступ к документам\n" # Временно скрыто
        f"• 📸 Поиск по фото - поиск товаров по изображению\n"
        f"• ❓ Помощь - информация о боте\n\n"
        f"💡 <i>Для начала работы нажмите на кнопку в меню</i>",
        reply_markup=reply_markup,
        parse_mode='HTML'
    )

def preprocess_image_for_search(image_path):
    """Предварительная обработка изображения для улучшения качества распознавания"""
    try:
        # Загружаем изображение
        img = cv2.imread(image_path)
        if img is None:
            logger.error(f"Не удалось загрузить изображение для предобработки: {image_path}")
            return None
            
        # Получаем размеры изображения
        height, width = img.shape[:2]
        
        # Если изображение слишком большое, уменьшаем его для ускорения обработки
        max_dimension = 1024
        if max(height, width) > max_dimension:
            scale = max_dimension / max(height, width)
            new_width = int(width * scale)
            new_height = int(height * scale)
            img = cv2.resize(img, (new_width, new_height), interpolation=cv2.INTER_AREA)
            logger.info(f"Изображение уменьшено до {new_width}x{new_height}")
            
        # Конвертируем в RGB для обработки с PIL
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img_pil = Image.fromarray(img_rgb)
        
        # Улучшаем контраст
        contrast_enhancer = ImageEnhance.Contrast(img_pil)
        enhanced_img = contrast_enhancer.enhance(1.2)  # Увеличиваем контраст на 20%
        
        # Увеличиваем резкость для лучшего распознавания деталей
        sharpness_enhancer = ImageEnhance.Sharpness(enhanced_img)
        enhanced_img = sharpness_enhancer.enhance(1.3)  # Увеличиваем резкость на 30%
        
        # Немного увеличиваем яркость, если изображение темное
        brightness_enhancer = ImageEnhance.Brightness(enhanced_img)
        enhanced_img = brightness_enhancer.enhance(1.1)  # Увеличиваем яркость на 10%
        
        # Улучшаем насыщенность цветов для лучшего распознавания брендов
        color_enhancer = ImageEnhance.Color(enhanced_img)
        enhanced_img = color_enhancer.enhance(1.2)  # Увеличиваем насыщенность на 20%
        
        # Создаем новый путь для обработанного изображения
        base_path, ext = os.path.splitext(image_path)
        enhanced_path = f"{base_path}_enhanced{ext}"
        
        # Сохраняем обработанное изображение
        enhanced_img.save(enhanced_path)
        logger.info(f"Создано улучшенное изображение: {enhanced_path}")
        
        return enhanced_path
    except Exception as e:
        logger.error(f"Ошибка при предобработке изображения: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return None

def enhanced_image_search(query_image_path, top_n=5, similarity_threshold=0.25):
    """
    Улучшенный поиск похожих изображений с использованием мультимодального подхода.
    Создает несколько вариантов исходного изображения с разными обработками и комбинирует результаты.
    
    Args:
        query_image_path: Путь к изображению для поиска
        top_n: Количество результатов для возврата
        similarity_threshold: Минимальный порог схожести
        
    Returns:
        Список кортежей (путь_к_изображению, схожесть)
    """
    try:
        # Проверяем существование файла
        if not os.path.exists(query_image_path):
            logger.error(f"Файл не существует: {query_image_path}")
            return []
        
        # Загружаем изображение для создания вариаций
        original_image = Image.open(query_image_path).convert('RGB')
        
        # Определяем тип инструмента и бренд для запроса - это критически важно для правильного поиска
        query_tool_type, query_tool_type_ru, tool_confidence = classify_tool_type(query_image_path)
        query_brand = detect_brand_by_color(query_image_path)
        if query_brand is None:
            query_brand = detect_brand_from_filename(query_image_path)
            if query_brand == "Неизвестный":
                query_brand = None
                
        logger.info(f"Запрос: определен тип инструмента {query_tool_type_ru} с уверенностью {tool_confidence:.2f}")
        logger.info(f"Запрос: определен бренд {query_brand}")
        
        # Временные файлы для хранения вариаций
        variation_files = []
        
        # 1. Оригинальное изображение
        original_results = find_similar_images(query_image_path, top_n=top_n*2, similarity_threshold=similarity_threshold)
        
        # 2. Вариация с увеличенным контрастом
        contrast_path = os.path.join("temp", f"contrast_{uuid.uuid4()}.jpg")
        contrast_enhancer = ImageEnhance.Contrast(original_image)
        contrast_img = contrast_enhancer.enhance(1.5)  # Значительно увеличиваем контраст
        contrast_img.save(contrast_path)
        variation_files.append(contrast_path)
        contrast_results = find_similar_images(contrast_path, top_n=top_n*2, similarity_threshold=similarity_threshold)
        
        # 3. Вариация с увеличенной резкостью
        sharpness_path = os.path.join("temp", f"sharp_{uuid.uuid4()}.jpg")
        sharpness_enhancer = ImageEnhance.Sharpness(original_image)
        sharp_img = sharpness_enhancer.enhance(1.8)  # Значительно увеличиваем резкость
        sharp_img.save(sharpness_path)
        variation_files.append(sharpness_path)
        sharp_results = find_similar_images(sharpness_path, top_n=top_n*2, similarity_threshold=similarity_threshold)
        
        # 4. Вариация с улучшенной яркостью
        brightness_path = os.path.join("temp", f"bright_{uuid.uuid4()}.jpg")
        brightness_enhancer = ImageEnhance.Brightness(original_image)
        bright_img = brightness_enhancer.enhance(1.3)  # Увеличиваем яркость
        bright_img.save(brightness_path)
        variation_files.append(brightness_path)
        bright_results = find_similar_images(brightness_path, top_n=top_n*2, similarity_threshold=similarity_threshold)
        
        # 5. Вариация с улучшенной насыщенностью цветов
        color_path = os.path.join("temp", f"color_{uuid.uuid4()}.jpg")
        color_enhancer = ImageEnhance.Color(original_image)
        color_img = color_enhancer.enhance(1.4)  # Увеличиваем насыщенность
        color_img.save(color_path)
        variation_files.append(color_path)
        color_results = find_similar_images(color_path, top_n=top_n*2, similarity_threshold=similarity_threshold)
        
        # Объединяем все результаты в один словарь для усреднения
        combined_results = {}
        
        # Добавляем результаты от каждой вариации с соответствующими весами
        for path, sim in original_results:
            combined_results[path] = {'similarity': sim, 'count': 1, 'total': sim}
            
        for path, sim in contrast_results:
            if path in combined_results:
                combined_results[path]['total'] += sim * 0.8  # Вес 0.8 для контраста
                combined_results[path]['count'] += 1
            else:
                combined_results[path] = {'similarity': sim * 0.8, 'count': 1, 'total': sim * 0.8}
                
        for path, sim in sharp_results:
            if path in combined_results:
                combined_results[path]['total'] += sim * 0.9  # Вес 0.9 для резкости
                combined_results[path]['count'] += 1
            else:
                combined_results[path] = {'similarity': sim * 0.9, 'count': 1, 'total': sim * 0.9}
                
        for path, sim in bright_results:
            if path in combined_results:
                combined_results[path]['total'] += sim * 0.7  # Вес 0.7 для яркости
                combined_results[path]['count'] += 1
            else:
                combined_results[path] = {'similarity': sim * 0.7, 'count': 1, 'total': sim * 0.7}
                
        for path, sim in color_results:
            if path in combined_results:
                combined_results[path]['total'] += sim * 0.85  # Вес 0.85 для цвета
                combined_results[path]['count'] += 1
            else:
                combined_results[path] = {'similarity': sim * 0.85, 'count': 1, 'total': sim * 0.85}
        
        # Пост-обработка результатов с приоритизацией типа инструмента и бренда
        weighted_results = []
        for path, data in combined_results.items():
            # Базовая средневзвешенная схожесть
            avg_similarity = data['total'] / data['count']
            
            # Уверенность на основе количества совпадений
            confidence_boost = min(data['count'] / 5 * 0.2, 0.2)  # Максимум 20% буста
            
            # Определяем тип инструмента для результата
            result_tool_type, result_tool_type_ru, _ = classify_tool_type(path)
            
            # Определяем бренд результата
            result_brand = detect_brand_by_color(path)
            if result_brand is None:
                result_brand = detect_brand_from_filename(path)
                if result_brand == "Неизвестный":
                    result_brand = None
            
            # Базовая скорректированная схожесть с учетом уверенности по количеству совпадений
            final_similarity = avg_similarity * (1 + confidence_boost)
            
            # Прямое сравнение цветовых гистограмм между запросом и результатом
            try:
                # Загружаем изображения для сравнения цветов
                query_img = cv2.imread(query_image_path)
                result_img = cv2.imread(path)
                
                if query_img is not None and result_img is not None:
                    # Конвертируем в HSV для лучшего сравнения цветов
                    query_hsv = cv2.cvtColor(query_img, cv2.COLOR_BGR2HSV)
                    result_hsv = cv2.cvtColor(result_img, cv2.COLOR_BGR2HSV)
                    
                    # Создаем цветовые гистограммы (оттенок и насыщенность)
                    h_bins = 30  # Увеличенное разрешение для оттенка
                    s_bins = 32  # Насыщенность 
                    histSize = [h_bins, s_bins]
                    h_ranges = [0, 180]
                    s_ranges = [0, 256]
                    ranges = h_ranges + s_ranges
                    channels = [0, 1]  # H и S каналы
                    
                    # Вычисляем гистограммы
                    query_hist = cv2.calcHist([query_hsv], channels, None, histSize, ranges)
                    result_hist = cv2.calcHist([result_hsv], channels, None, histSize, ranges)
                    
                    # Нормализуем гистограммы
                    cv2.normalize(query_hist, query_hist, 0, 1, cv2.NORM_MINMAX)
                    cv2.normalize(result_hist, result_hist, 0, 1, cv2.NORM_MINMAX)
                    
                    # Сравниваем гистограммы (0-1, где 1 - идеальное совпадение)
                    color_similarity = cv2.compareHist(query_hist, result_hist, cv2.HISTCMP_CORREL)
                    
                    # Избегаем отрицательных значений
                    color_similarity = max(0, color_similarity)
                    
                    logger.info(f"Цветовая схожесть для {os.path.basename(path)}: {color_similarity:.3f}")
                    
                    # Значительно усиливаем приоритет для инструментов с похожим цветом
                    # Это решит проблему, когда синий Makita соответствует черному шуруповерту
                    color_boost = 1.0 + (color_similarity * 5.0)  # До 6x буст для цветового соответствия
                    final_similarity *= color_boost
                    
                    logger.info(f"Цветовой буст для {os.path.basename(path)}: {color_boost:.2f}x")
            except Exception as e:
                logger.warning(f"Ошибка при сравнении цветов для {path}: {e}")
            
            # Очень сильно увеличиваем приоритет для совпадения типа инструмента 
            # (это самый важный фактор - шуруповерт должен сопоставляться с шуруповертом)
            if query_tool_type == result_tool_type and query_tool_type != "unknown":
                # Если совпадает тип инструмента - очень сильно повышаем приоритет
                type_match_boost = 8.0  # Умножаем в 8 раз для совпадения типа
                final_similarity *= type_match_boost
                logger.info(f"Сильное повышение приоритета для {path} - совпадение типа {query_tool_type_ru}")
            elif query_tool_type != "unknown" and result_tool_type != "unknown" and query_tool_type != result_tool_type:
                # Если типы не совпадают - сильно понижаем приоритет
                final_similarity *= 0.05  # Понижаем до 5% для разных типов
                logger.info(f"Сильное понижение приоритета для {path} - разные типы {query_tool_type_ru} и {result_tool_type_ru}")
                
            # Дополнительный приоритет для совпадения бренда
            if query_brand and result_brand and query_brand == result_brand:
                # Для совпадения бренда тоже существенно увеличиваем приоритет
                brand_match_boost = 3.0  # Умножаем в 3 раза для совпадения бренда
                final_similarity *= brand_match_boost
                logger.info(f"Повышение приоритета для {path} - совпадение бренда {query_brand}")
            elif query_brand and result_brand and query_brand != result_brand:
                # Для разных брендов понижаем приоритет
                final_similarity *= 0.2
                logger.info(f"Понижение приоритета для {path} - разные бренды {query_brand} и {result_brand}")
            
            # Ограничиваем финальное значение схожести максимумом 1.0
            final_similarity = min(final_similarity, 1.0)
            
            weighted_results.append((path, final_similarity))
        
        # Сортируем результаты по схожести
        weighted_results.sort(key=lambda x: x[1], reverse=True)
        
        # Берем только top_n результатов
        final_results = weighted_results[:top_n]
        
        # Логируем результаты
        logger.info(f"Улучшенный поиск: найдено {len(final_results)} результатов из {len(combined_results)} кандидатов")
        for i, (path, sim) in enumerate(final_results):
            logger.info(f"Результат #{i+1}: {os.path.basename(path)}, схожесть {sim:.3f}")
        
        # Удаляем временные файлы
        for file_path in variation_files:
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                logger.warning(f"Не удалось удалить временный файл {file_path}: {e}")
        
        return final_results
        
    except Exception as e:
        logger.error(f"Ошибка в enhanced_image_search: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        
        # В случае ошибки используем базовый поиск
        logger.info("Возвращаемся к базовому поиску из-за ошибки")
        return find_similar_images(query_image_path, top_n=top_n, similarity_threshold=similarity_threshold)

async def photo_search_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для поиска по фото с выбором отдела"""
    user_id = update.effective_user.id

    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("photo_search", user_id)

    # Отключаем предыдущий режим ожидания фото, если был активен
    context.user_data["awaiting_photo"] = False
    
    # Создаем клавиатуру с отделами
    keyboard = [
        ["🎨 Краска", "🧱 Стройка"],
        ["🪑 Столярка", "⚡ Электрика"],
        ["🔨 Инструменты", "🚿 Водоснабжение"],
        ["🌱 Сад", "🔧 Скобянка"],
        ["🔙 Назад в меню"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(
        "📸 *Поиск по фото*\n\n"
        "Сначала выберите отдел, в котором хотите искать товар:\n"
        "• 🎨 Краска - краски, эмали, лаки\n"
        "• 🧱 Стройка - цемент, гипс, штукатурка\n"
        "• 🪑 Столярка - деревообработка, фанера\n"
        "• ⚡ Электрика - розетки, провода, выключатели\n"
        "• 🔨 Инструменты - все виды инструментов\n"
        "• 🚿 Водоснабжение - трубы, краны, фитинги\n"
        "• 🌱 Сад - товары для сада и огорода\n"
        "• 🔧 Скобянка - метизы, крепежи, фурнитура\n\n"
        "💡 Выбор отдела поможет получить более точные результаты",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def department_selection_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик выбора отдела перед поиском по фото"""
    user_id = update.effective_user.id
    selected_department = update.message.text
    
    # Сохраняем выбранный отдел в контексте пользователя
    context.user_data["selected_department"] = selected_department
    
    # Включаем режим ожидания фотографии
    context.user_data["awaiting_photo"] = True
    
    # Получаем эмодзи отдела
    department_emoji = selected_department.split()[0]
    
    # Создаем клавиатуру для отмены
    keyboard = [["🔙 Назад к выбору отдела"], ["🔙 Назад в меню"]]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Логируем использование команды с указанием отдела
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command(f"photo_search_{selected_department}", user_id)
    
    await update.message.reply_text(
        f"{department_emoji} *Поиск в отделе {selected_department}*\n\n"
        f"Теперь отправьте фотографию товара для поиска.\n\n"
        f"💡 Советы для лучшего результата:\n"
        f"• Фотографируйте в хорошем освещении\n"
        f"• Держите камеру параллельно товару\n"
        f"• Избегайте теней и отражений\n"
        f"• Следите, чтобы товар занимал большую часть кадра",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def back_to_departments_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик возврата к выбору отдела"""
    # Сбрасываем текущие состояния
    context.user_data["awaiting_photo"] = False
    
    # Вызываем обработчик поиска по фото для показа меню отделов
    await photo_search_handler(update, context)

async def show_error_message(update: Update, error_type="general"):
    """Показывает сообщение об ошибке в зависимости от типа"""
    error_messages = {
        "access_denied": "⛔ *Доступ запрещен*\n\nВы не имеете доступа к этому боту.\nПожалуйста, обратитесь к администратору.",
        "invalid_command": "❌ *Неизвестная команда*\n\nВведенная команда не распознана.\nИспользуйте меню для навигации.",
        "general": "❌ *Произошла ошибка*\n\nПожалуйста, попробуйте еще раз или обратитесь к администратору."
    }
    
    message = error_messages.get(error_type, error_messages["general"])
    
    await update.message.reply_text(
        message,
        parse_mode='Markdown'
    )

async def help_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик команды помощи"""
    user_id = update.effective_user.id
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("help", user_id)
    
    # Проверяем, есть ли пользователь в белом списке
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Формируем текст справки
    help_text = (
        "*❓ СПРАВОЧНАЯ ИНФОРМАЦИЯ ПО БОТУ*\n\n"
        "*О БОТЕ:*\n"
        "Данный Telegram-бот разработан для упрощения поиска строительных товаров и инструментов. "
        "С его помощью вы можете найти нужный товар по фото, получить информацию о магазинах, "
        "ознакомиться с каталогом скобяных изделий и многое другое.\n\n"
        
        "*ОСНОВНЫЕ КОМАНДЫ:*\n"
        "• /start - запуск бота и возврат в главное меню\n"
        "• /help - вызов этой справки\n"
        "• /stop - отмена текущей операции\n\n"
        
        "*ОСНОВНЫЕ РАЗДЕЛЫ:*\n"
        "• 📞 *Контакты* - доступ к информации о магазинах, логистике и другим контактным данным\n"
        "• 📸 *Поиск по фото* - поиск товаров с помощью фотографии\n"
        "• ❓ *Помощь* - данная справка\n\n"
        
        "*РАЗДЕЛ КОНТАКТЫ:*\n"
        "• 🏪 *Магазины* - адреса и контакты магазинов\n"
        "• 🚚 *Логистика* - информация о доставке и перевозках\n"
        "• 🗺 *Карты* - расположение объектов на карте\n"
        "• 🔧 *Скобянка* - справочник по скобяным изделиям\n\n"
        
        "*ПОИСК ПО ФОТО:*\n"
        "Эта функция позволяет искать товары, сфотографировав их. Для использования:\n"
        "1. Нажмите кнопку 📸 *Поиск по фото*\n"
        "2. Выберите отдел, в котором нужно искать товар\n"
        "3. Сделайте четкую фотографию товара и отправьте боту\n"
        "4. Дождитесь результатов поиска\n\n"
        
        "*СОВЕТЫ ПО ИСПОЛЬЗОВАНИЮ:*\n"
        "• Для лучшего распознавания делайте фото при хорошем освещении\n"
        "• Старайтесь держать камеру параллельно товару\n"
        "• Избегайте теней и бликов на фотографии\n"
        "• Если не получаете нужные результаты, попробуйте выбрать другой отдел или сделать фото с другого ракурса\n\n"
        
        "*НАВИГАЦИЯ:*\n"
        "• Используйте кнопки на клавиатуре для переходов между разделами\n"
        "• Кнопка 🔙 *Назад в меню* возвращает в главное меню из любого раздела\n"
        "• Команда /stop отменяет текущую операцию\n\n"
        
        "💡 По любым вопросам и проблемам обращайтесь к администратору."
    )
    
    # Показываем справку
    await update.message.reply_text(
        help_text,
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup([["🔙 Назад в меню"]], resize_keyboard=True)
    )

async def stop_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик команды /stop - отменяет текущую операцию"""
    user_id = update.effective_user.id
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("stop", user_id)
    
    # Сбрасываем все состояния пользователя
    if 'state' in context.user_data:
        del context.user_data['state']
    
    if 'awaiting_photo' in context.user_data:
        context.user_data['awaiting_photo'] = False
    
    # Отправляем сообщение
    await update.message.reply_text(
        "✅ Текущая операция отменена. Возвращаемся в главное меню.",
        reply_markup=ReplyKeyboardMarkup([
            ["📞 Контакты", "📸 Поиск по фото"],
            ["❓ Помощь"]
        ], resize_keyboard=True)
    )

async def get_stats_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /stats - показывает статистику использования бота"""
    user_id = update.effective_user.id
    config = load_config()
    
    # Проверяем, является ли пользователь админом
    if user_id not in config.get('admins', []):
        await update.message.reply_text("⛔ Доступ запрещен")
        return
    
    # Получаем статистику
    analytics = context.bot_data.get('analytics')
    if not analytics:
        await update.message.reply_text("❌ Система аналитики недоступна")
        return
    
    # Получаем статистику команд
    command_stats = analytics.get_command_stats()
    
    if not command_stats:
        await update.message.reply_text("📊 Статистика пока не собрана")
        return
    
    # Формируем сообщение со статистикой
    stats_message = "*📊 Статистика использования бота*\n\n"
    
    for command, count in command_stats:
        stats_message += f"• {command}: {count} раз\n"
    
    await update.message.reply_text(
        stats_message,
        parse_mode='Markdown'
    )

async def contacts_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела контактов"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("contacts", user_id)
    
    # Создаем клавиатуру для раздела контактов
    keyboard = [
        ["🏪 Магазины"],
        ["🗺 Карты", "🔧 Скобянка"],
        ["🔙 Назад в меню"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Отправляем сообщение с меню
    await update.message.reply_text(
        "*📞 Контакты и информация*\n\n"
        "Выберите нужный раздел:\n"
        "• 🏪 Магазины - адреса и телефоны магазинов\n"
        "• 🗺 Карты - расположение объектов на карте\n"
        "• 🔧 Скобянка - каталог скобяных изделий\n\n"
        "💡 _Используйте кнопки для навигации_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def products_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела товаров"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("products", user_id)
    
    # Создаем клавиатуру для раздела товаров
    keyboard = [
        ["🎨 Цвета", "🔧 Скобянка"],
        ["🔙 Назад в меню"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Отправляем сообщение с меню
    await update.message.reply_text(
        "*📦 Товары*\n\n"
        "Выберите нужный раздел:\n"
        "• 🎨 Цвета - база данных цветов\n"
        "• 🔧 Скобянка - каталог скобяных изделий\n\n"
        "💡 _Используйте кнопки для навигации_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def documents_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела документов"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("documents", user_id)
    
    # Создаем клавиатуру для раздела документов
    keyboard = [
        ["📄 ЕГАИС"],
        ["🔙 Назад в меню"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Отправляем сообщение с меню
    await update.message.reply_text(
        "*📄 Документы*\n\n"
        "Выберите нужный раздел:\n"
        "• 📄 ЕГАИС - документация по ЕГАИС\n\n"
        "💡 _Нажмите на кнопку для просмотра документов_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def stores_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела магазинов"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("stores", user_id)
    
    # Создаем клавиатуру только для возврата
    keyboard = [["🔙 Назад в контакты"]]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Устанавливаем состояние поиска магазинов
    context.user_data['state'] = 'searching_stores'
    
    # Отправляем сообщение с инструкцией по поиску
    await update.message.reply_text(
        "*🏪 Поиск по таблице*\n\n"
        "Введите наименование или отдел для поиска.\n"
        "Поиск выполняется по частичному совпадению текста.\n\n"
        "💡 _Пример: исп_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def maps_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела карт"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("maps", user_id)
    
    # Создаем клавиатуру для возврата
    keyboard = [["🔙 Назад в контакты"]]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Отправляем сообщение
    await update.message.reply_text(
        "*🗺 Карты*\n\n"
        "В разработке. Скоро здесь появятся интерактивные карты с расположением магазинов и складов.",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def logistics_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела логистики"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("logistics", user_id)
    
    # Создаем клавиатуру для возврата
    keyboard = [["🔙 Назад в контакты"]]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Отправляем сообщение
    await update.message.reply_text(
        "*🚚 Логистика*\n\n"
        "Информация о доставке товаров:\n\n"
        "• Доставка осуществляется в течение 1-3 рабочих дней\n"
        "• Стоимость доставки зависит от веса и габаритов заказа\n"
        "• Минимальная стоимость доставки - 300 руб.\n\n"
        "Для уточнения сроков и стоимости обратитесь к менеджеру.",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def skobyanka_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для раздела скобянки"""
    user_id = update.effective_user.id
    
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("skobyanka", user_id)
    
    # Устанавливаем состояние поиска скобянки
    context.user_data['state'] = 'searching_skobyanka'
    
    # Создаем клавиатуру для возврата
    keyboard = [["🔙 Назад в контакты"], ["🔙 Назад в меню"]]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    # Отправляем сообщение
    await update.message.reply_text(
        "*🔧 Каталог скобяных изделий*\n\n"
        "Введите поисковый запрос для поиска в каталоге скобяных изделий.\n"
        "Поиск выполняется по частичному совпадению текста.\n"
        "Можно искать по:\n"
        "• Наименованию\n"
        "• Артикулу\n"
        "• Размеру\n"
        "• Другим параметрам\n\n"
        "💡 _Пример: винт 5_",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def back_to_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик возврата в главное меню"""
    user_id = update.effective_user.id
    
    # Логируем использование команды
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("back_to_menu", user_id)
    
    # Сбрасываем все состояния
    if 'state' in context.user_data:
        del context.user_data['state']
    if 'awaiting_photo' in context.user_data:
        context.user_data['awaiting_photo'] = False
    if 'selected_department' in context.user_data:
        del context.user_data['selected_department']
    
    # Вызываем обработчик команды /start для показа главного меню
    await start(update, context)

async def back_to_products_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик возврата в раздел товаров"""
    await products_handler(update, context)

async def text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик текстовых сообщений"""
    user_id = update.effective_user.id
    text = update.message.text
    
    # Проверяем, есть ли пользователь в белом списке
    if not is_allowed_user(user_id):
        await show_error_message(update, "access_denied")
        return
    
    # Проверяем текущее состояние пользователя
    state = context.user_data.get('state')
    
    # Логируем использование текстового поиска
    analytics = context.bot_data.get('analytics')
    if analytics:
        analytics.log_command("text_search", user_id)
    
    if state == 'searching_colors':
        # Поиск цветов (код не меняется)
        config = load_config()
        colors_file = config.get('colors_file')
        
        if not colors_file or not os.path.exists(colors_file):
            await update.message.reply_text("❌ Файл с базой цветов не найден")
            return
        
        results = await search_in_colors(text, colors_file, context)
        
        if results:
            # Отправляем найденные результаты
            for i, result in enumerate(results[:10]):  # Ограничиваем до 10 результатов
                await update.message.reply_text(
                    result,
                    parse_mode='Markdown'
                )
                
            if len(results) > 10:
                await update.message.reply_text(
                    f"🔍 Найдено ещё {len(results) - 10} результатов. Уточните запрос для более конкретных результатов."
                )
        else:
            await update.message.reply_text(
                "❌ Ничего не найдено. Попробуйте другой запрос."
            )
    
    elif state == 'searching_stores':
        # Поиск в таблице table_2.xlsx
        results = await search_in_table2(text, context)
        
        if results:
            await update.message.reply_text(
                f"*🏪 Результаты поиска по запросу:* '{text}'\n",
                parse_mode='Markdown'
            )
            
            # Отправляем найденные результаты
            for i, result in enumerate(results[:10]):  # Ограничиваем до 10 результатов
                await update.message.reply_text(
                    result,
                    parse_mode='Markdown'
                )
                
            if len(results) > 10:
                await update.message.reply_text(
                    f"🔍 Найдено ещё {len(results) - 10} результатов. Уточните запрос для более точных результатов."
                )
        else:
            await update.message.reply_text(
                "❌ Ничего не найдено по вашему запросу. Попробуйте изменить поисковый запрос."
            )
    
    elif state == 'searching_skobyanka':
        # Поиск в каталоге скобянки с прямым указанием файла
        results = await search_in_skobyanka_direct(text, context)
        
        if results:
            await update.message.reply_text(
                f"*🔧 Результаты поиска в скобянке по запросу:* '{text}'\n",
                parse_mode='Markdown'
            )
            
            # Отправляем найденные результаты
            for i, result in enumerate(results[:10]):  # Ограничиваем до 10 результатов
                await update.message.reply_text(
                    result,
                    parse_mode='Markdown'
                )
                
            if len(results) > 10:
                await update.message.reply_text(
                    f"🔍 Найдено ещё {len(results) - 10} результатов. Уточните запрос для более точных результатов."
                )
        else:
            await update.message.reply_text(
                "❌ Ничего не найдено по вашему запросу. Попробуйте изменить поисковый запрос."
            )
    
    elif state == 'awaiting_new_user_id':
        # Добавление нового пользователя
        try:
            new_user_id = int(text.strip())
            config = load_config()
            whitelist = config.get('whitelist', [])
            
            if new_user_id in whitelist:
                await update.message.reply_text("❌ Этот пользователь уже добавлен.")
            else:
                # Добавляем пользователя в whitelist
                whitelist.append(new_user_id)
                config['whitelist'] = whitelist
                
                # Сохраняем обновленную конфигурацию
                with open("key.key", "rb") as key_file:
                    key = key_file.read()
                fernet = Fernet(key)
                encrypted_data = fernet.encrypt(json.dumps(config).encode())
                
                with open("config.encrypted", "wb") as config_file:
                    config_file.write(encrypted_data)
                
                await update.message.reply_text(f"✅ Пользователь с ID {new_user_id} успешно добавлен.")
                
                # Сбрасываем состояние
                context.user_data.pop('state', None)
        except ValueError:
            await update.message.reply_text("❌ Неверный формат ID. Пожалуйста, введите числовой ID.")
    
    elif state == 'awaiting_remove_user_id':
        # Удаление пользователя
        try:
            user_id_to_remove = int(text.strip())
            config = load_config()
            whitelist = config.get('whitelist', [])
            
            if user_id_to_remove not in whitelist:
                await update.message.reply_text("❌ Этот пользователь не найден в списке.")
            else:
                # Удаляем пользователя из whitelist
                whitelist.remove(user_id_to_remove)
                config['whitelist'] = whitelist
                
                # Сохраняем обновленную конфигурацию
                with open("key.key", "rb") as key_file:
                    key = key_file.read()
                fernet = Fernet(key)
                encrypted_data = fernet.encrypt(json.dumps(config).encode())
                
                with open("config.encrypted", "wb") as config_file:
                    config_file.write(encrypted_data)
                
                await update.message.reply_text(f"✅ Пользователь с ID {user_id_to_remove} успешно удален.")
                
                # Сбрасываем состояние
                context.user_data.pop('state', None)
        except ValueError:
            await update.message.reply_text("❌ Неверный формат ID. Пожалуйста, введите числовой ID.")
    
    else:
        # Неизвестное состояние, показываем сообщение об ошибке
        await update.message.reply_text(
            "❓ Не понимаю вашего запроса. Пожалуйста, используйте меню для навигации.",
            reply_markup=ReplyKeyboardMarkup([["🔙 Назад в меню"]], resize_keyboard=True)
        )

async def add_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик команды /add_user для добавления пользователя"""
    user_id = update.effective_user.id
    config = load_config()
    
    # Проверяем, является ли пользователь администратором
    if user_id not in config.get('admins', []):
        await update.message.reply_text("⛔ У вас нет доступа к этой команде.")
        return
    
    # Проверяем наличие аргументов
    if not context.args:
        await update.message.reply_text(
            "❌ Необходимо указать ID пользователя.\n"
            "Пример: /add_user 123456789"
        )
        return
    
    try:
        # Получаем ID нового пользователя
        new_user_id = int(context.args[0])
        
        # Получаем текущий список пользователей
        whitelist = config.get('whitelist', [])
        
        # Проверяем, не добавлен ли уже этот пользователь
        if new_user_id in whitelist:
            await update.message.reply_text(f"❌ Пользователь с ID {new_user_id} уже в списке.")
            return
        
        # Добавляем пользователя
        whitelist.append(new_user_id)
        config['whitelist'] = whitelist
        
        # Сохраняем обновленную конфигурацию
        with open("key.key", "rb") as key_file:
            key = key_file.read()
        fernet = Fernet(key)
        encrypted_data = fernet.encrypt(json.dumps(config).encode())
        
        with open("config.encrypted", "wb") as config_file:
            config_file.write(encrypted_data)
        
        await update.message.reply_text(f"✅ Пользователь с ID {new_user_id} успешно добавлен.")
        
    except ValueError:
        await update.message.reply_text("❌ Неверный формат ID. ID должен быть числом.")
    except Exception as e:
        logger.error(f"Ошибка при добавлении пользователя: {e}")
        await update.message.reply_text(f"❌ Произошла ошибка: {str(e)}")

class Analytics:
    """Класс для сбора и анализа статистики использования бота"""
    
    def __init__(self):
        """Инициализация базы данных для аналитики"""
        try:
            self.conn = sqlite3.connect('analytics.db', check_same_thread=False)
            self.cursor = self.conn.cursor()
            
            # Создаем таблицу для команд, если её нет
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS commands (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    command TEXT NOT NULL,
                    user_id INTEGER NOT NULL,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Создаем таблицу для пользователей, если её нет
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY,
                    first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    command_count INTEGER DEFAULT 1
                )
            ''')
            
            self.conn.commit()
            logger.info("✅ База данных аналитики успешно инициализирована")
        except Exception as e:
            logger.error(f"❌ Ошибка при инициализации базы данных аналитики: {e}")
    
    def log_command(self, command, user_id):
        """Логирование использования команды"""
        try:
            # Записываем команду
            self.cursor.execute(
                "INSERT INTO commands (command, user_id) VALUES (?, ?)",
                (command, user_id)
            )
            
            # Обновляем информацию о пользователе
            self.cursor.execute(
                """
                INSERT INTO users (user_id, command_count) 
                VALUES (?, 1)
                ON CONFLICT(user_id) 
                DO UPDATE SET 
                    last_seen = CURRENT_TIMESTAMP,
                    command_count = command_count + 1
                """,
                (user_id,)
            )
            
            self.conn.commit()
        except Exception as e:
            logger.error(f"❌ Ошибка при логировании команды: {e}")
    
    def get_command_stats(self):
        """Получение статистики использования команд"""
        try:
            self.cursor.execute(
                """
                SELECT command, COUNT(*) as count 
                FROM commands 
                GROUP BY command 
                ORDER BY count DESC
                """
            )
            return self.cursor.fetchall()
        except Exception as e:
            logger.error(f"❌ Ошибка при получении статистики команд: {e}")
            return []
    
    def get_user_stats(self):
        """Получение статистики пользователей"""
        try:
            self.cursor.execute(
                """
                SELECT user_id, first_seen, last_seen, command_count 
                FROM users 
                ORDER BY command_count DESC
                """
            )
            return self.cursor.fetchall()
        except Exception as e:
            logger.error(f"❌ Ошибка при получении статистики пользователей: {e}")
            return []

async def search_in_table2(query: str, context) -> list:
    """
    Поиск в таблице table_2.xlsx по колонкам "Наименование" и "Отдел"
    """
    try:
        # Задаем точный путь к файлу
        excel_file = "C:\\Users\\PluxuryPC\\PycharmProjects\\PythonProject5\\data\\table_2.xlsx"
        
        # Проверяем наличие файла
        if not os.path.exists(excel_file):
            logger.error(f"❌ Файл таблицы не найден: {excel_file}")
            return ["❌ Файл с таблицей не найден"]
            
        # Читаем Excel файл
        df = pd.read_excel(excel_file)
        logger.info(f"Загружена таблица. Количество строк: {len(df)}")
        logger.info(f"Колонки в таблице: {df.columns.tolist()}")
        
        # Проверяем наличие необходимых колонок
        required_columns = ['Наименование', 'Отдел']
        missing_columns = [col for col in required_columns if col not in df.columns]
        
        if missing_columns:
            logger.error(f"❌ В таблице отсутствуют колонки: {', '.join(missing_columns)}")
            return ["❌ Ошибка в структуре таблицы: отсутствуют необходимые колонки"]

        # Если запрос пустой, возвращаем первые 15 строк
        if not query.strip():
            results = []
            for _, row in df.head(15).iterrows():
                result_parts = []
                result_parts.append(f"🏪 *{row['Наименование']}*")
                
                # Добавляем остальные поля
                for col in df.columns:
                    if col != 'Наименование':
                        value = row[col]
                        if pd.notna(value):  # Проверяем, что значение не NaN
                            # Форматируем числовое значение
                            formatted_value = format_numeric_value(value)
                            result_parts.append(f"• {col}: {formatted_value}")
                
                results.append("\n".join(result_parts))
            return results
            
        # Приводим запрос к нижнему регистру для поиска
        query = query.lower().strip()
        logger.info(f"Поисковый запрос: {query}")

        # Поиск по колонкам "Наименование" и "Отдел"
        matches = df[
            df['Наименование'].astype(str).str.lower().str.contains(query, na=False) |
            df['Отдел'].astype(str).str.lower().str.contains(query, na=False)
        ]
        
        logger.info(f"Найдено совпадений: {len(matches)}")
        
        if not matches.empty:
            # Форматируем результаты
            results = []
            for _, row in matches.iterrows():
                result_parts = []
                result_parts.append(f"🏪 *{row['Наименование']}*")
                
                # Добавляем остальные поля
                for col in df.columns:
                    if col != 'Наименование':
                        value = row[col]
                        if pd.notna(value):  # Проверяем, что значение не NaN
                            # Форматируем числовое значение
                            formatted_value = format_numeric_value(value)
                            result_parts.append(f"• {col}: {formatted_value}")
                
                results.append("\n".join(result_parts))
            
            return results
        else:
            logger.info("Ничего не найдено по запросу")
            return []
                
    except Exception as e:
        logger.error(f"Ошибка при поиске в таблице: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return ["❌ Произошла ошибка при поиске"]

async def search_in_skobyanka_direct(query: str, context) -> list:
    """
    Поиск в таблице skobyanka.xlsx по всем колонкам
    """
    try:
        # Задаем точный путь к файлу
        excel_file = "C:\\Users\\PluxuryPC\\PycharmProjects\\PythonProject5\\data\\skobyanka.xlsx"
        
        # Проверяем наличие файла
        if not os.path.exists(excel_file):
            logger.error(f"❌ Файл скобянки не найден: {excel_file}")
            return ["❌ Файл с каталогом скобянки не найден"]
            
        # Читаем Excel файл
        df = pd.read_excel(excel_file)
        logger.info(f"Загружена таблица скобянки. Количество строк: {len(df)}")
        logger.info(f"Колонки в таблице: {df.columns.tolist()}")
        
        # Если запрос пустой, возвращаем первые 15 строк
        if not query.strip():
            results = []
            for _, row in df.head(15).iterrows():
                result_parts = []
                
                # Определяем основное название/артикул
                name_column = next((col for col in ['Наименование', 'Товар', 'Артикул'] if col in df.columns), df.columns[0])
                result_parts.append(f"🔧 *{row[name_column]}*")
                
                # Добавляем остальные поля
                for col in df.columns:
                    if col != name_column:
                        value = row[col]
                        if pd.notna(value):  # Проверяем, что значение не NaN
                            # Форматируем числовое значение, удаляя .0 у целых чисел
                            formatted_value = format_numeric_value(value)
                            result_parts.append(f"• {col}: {formatted_value}")
                
                results.append("\n".join(result_parts))
            return results
            
        # Приводим запрос к нижнему регистру для поиска
        query = query.lower().strip()
        logger.info(f"Поисковый запрос для скобянки: {query}")

        # Поиск по всем колонкам
        matches = df.apply(
            lambda row: any(
                str(value).lower().find(query) != -1 
                for value in row if pd.notna(value)
            ), 
            axis=1
        )
        
        results_df = df[matches]
        logger.info(f"Найдено совпадений: {len(results_df)}")
        
        if not results_df.empty:
            # Форматируем совпадения
            results = []
            for _, row in results_df.iterrows():
                result_parts = []
                
                # Определяем основное название/артикул
                name_column = next((col for col in ['Наименование', 'Товар', 'Артикул'] if col in df.columns), df.columns[0])
                result_parts.append(f"🔧 *{row[name_column]}*")
                
                # Добавляем остальные поля
                for col in df.columns:
                    if col != name_column:
                        value = row[col]
                        if pd.notna(value):  # Проверяем, что значение не NaN
                            # Форматируем числовое значение, удаляя .0 у целых чисел
                            formatted_value = format_numeric_value(value)
                            result_parts.append(f"• {col}: {formatted_value}")
                
                results.append("\n".join(result_parts))
            
            return results[:10]  # Ограничиваем до 10 результатов
        else:
            return []
                
    except Exception as e:
        logger.error(f"Ошибка при поиске в скобянке: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return ["❌ Произошла ошибка при поиске"]

def format_numeric_value(value):
    """
    Форматирует числовое значение для вывода, удаляя десятичную точку и нули у целых чисел
    """
    try:
        # Если значение - число
        if isinstance(value, (int, float)):
            # Проверяем, является ли число целым (например, 450.0)
            if value.is_integer():
                return str(int(value))  # Конвертируем в целое число без .0
            else:
                return str(value)  # Оставляем как есть для дробных чисел
        # Если это уже строка или другой тип, возвращаем как есть
        return str(value)
    except:
        # В случае ошибки просто возвращаем строковое представление
        return str(value)


# Заглушка для функций Cloudinary
def initialize_cloudinary():
    """Заглушка для инициализации Cloudinary - всегда возвращает False"""
    logger.info("⚠️ Cloudinary API отключено, используется только локальный поиск")
    return False

# Заглушка для функции check_visual_search_availability
def check_visual_search_availability():
    """Заглушка для проверки доступности Visual Search в Cloudinary - всегда False"""
    return False

# Заглушка для поиска через Cloudinary
def search_similar_images_cloudinary(image_path, max_results=5, folder=None):
    """Заглушка для поиска в Cloudinary - всегда возвращает пустой список"""
    logger.info("⚠️ Поиск через Cloudinary отключен, используйте локальный поиск")
    return []

def detect_tool_box(image):
    """Определяет, находится ли инструмент в коробке"""
    try:
        # Конвертируем в оттенки серого
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # Находим контуры
        _, thresh = cv2.threshold(gray, 120, 255, cv2.THRESH_BINARY)
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        # Если контуров нет, возвращаем False
        if not contours:
            return False
        
        # Получаем размеры изображения
        height, width = image.shape[:2]
        image_area = height * width
        
        # Ищем большие прямоугольные контуры (потенциально коробки)
        for contour in contours:
            area = cv2.contourArea(contour)
            # Если контур занимает значительную часть изображения
            if area > image_area * 0.3:
                # Проверяем прямоугольность контура
                perimeter = cv2.arcLength(contour, True)
                approx = cv2.approxPolyDP(contour, 0.04 * perimeter, True)
                if len(approx) == 4:  # Прямоугольник
                    return True
        
        # Дополнительно проверяем наличие специфичных цветов для коробок инструментов
        # Многие коробки имеют яркие цвета (Makita - синий, DeWalt - желтый)
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        
        # Синие коробки (Makita, Bosch, Dexter)
        lower_blue = np.array([90, 50, 50])
        upper_blue = np.array([130, 255, 255])
        blue_mask = cv2.inRange(hsv, lower_blue, upper_blue)
        blue_pixels = cv2.countNonZero(blue_mask)
        
        # Желтые коробки (DeWalt)
        lower_yellow = np.array([20, 100, 100])
        upper_yellow = np.array([35, 255, 255])
        yellow_mask = cv2.inRange(hsv, lower_yellow, upper_yellow)
        yellow_pixels = cv2.countNonZero(yellow_mask)
        
        # Определяем порог для обнаружения коробки
        if blue_pixels > image_area * 0.2 or yellow_pixels > image_area * 0.2:
            return True
            
        return False
        
    except Exception as e:
        logger.error(f"Ошибка при определении коробки: {e}")
        return False

def extract_tool_from_box(image):
    """Извлекает инструмент из коробки, фокусируясь на самом инструменте"""
    try:
        # Размеры изображения
        height, width = image.shape[:2]
        
        # Предполагаем, что инструмент находится в центре коробки
        # Вырезаем центральную часть изображения
        center_x, center_y = width // 2, height // 2
        
        # Получаем размеры ROI (60-80% от оригинального изображения)
        roi_width = int(width * 0.7)
        roi_height = int(height * 0.7)
        
        # Координаты верхнего левого угла ROI
        x1 = max(0, center_x - roi_width // 2)
        y1 = max(0, center_y - roi_height // 2)
        
        # Координаты нижнего правого угла ROI
        x2 = min(width, x1 + roi_width)
        y2 = min(height, y1 + roi_height)
        
        # Вырезаем ROI
        roi = image[y1:y2, x1:x2]
        
        # Проверяем, получили ли мы что-то полезное
        if roi.size == 0:
            logger.warning("Не удалось извлечь ROI, возвращаем оригинальное изображение")
            return image
            
        return roi
        
    except Exception as e:
        logger.error(f"Ошибка при извлечении инструмента из коробки: {e}")
        return None

# Добавляем функцию инициализации YOLO
def initialize_yolo_model():
    """Инициализация модели YOLO для обнаружения объектов"""
    global yolo_model
    try:
        # Загружаем предварительно обученную модель YOLOv8n
        yolo_model = YOLO("yolov8n.pt")
        logger.info("✅ Модель YOLO успешно инициализирована")
        return True
    except Exception as e:
        logger.error(f"❌ Ошибка при инициализации модели YOLO: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return False

# Добавляем функцию для обнаружения инструментов на изображении
def detect_tools_on_image(image_path):
    """Обнаруживает инструменты на изображении и возвращает их ограничивающие рамки"""
    global yolo_model
    
    try:
        # Проверяем, инициализирована ли модель YOLO
        if yolo_model is None:
            if not initialize_yolo_model():
                return []
                
        # Определяем классы, которые могут содержать инструменты
        # YOLO COCO классы, относящиеся к инструментам или похожим объектам
        tool_class_ids = [39, 40, 41, 42, 43, 44, 45, 76, 77]  # cell phone, mouse, remote, keyboard, laptop, и т.д.
        
        # Запускаем обнаружение объектов
        results = yolo_model(image_path)
        
        # Получаем информацию о найденных объектах
        detected_objects = []
        
        if len(results) > 0:
            result = results[0]  # Берем результат для первого изображения
            boxes = result.boxes  # Получаем ограничивающие рамки
            
            for i, box in enumerate(boxes):
                # Получаем координаты рамки
                x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                # Округляем координаты до целых чисел
                x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)
                
                # Получаем класс и достоверность
                cls = int(box.cls[0].item())
                conf = float(box.conf[0].item())
                
                # Если класс не входит в наш список, проверяем уверенность
                # Считаем, что любой объект с высокой уверенностью может быть инструментом
                is_tool = cls in tool_class_ids or conf > 0.70
                
                if is_tool:
                    detected_objects.append({
                        'bbox': (x1, y1, x2, y2),
                        'confidence': conf,
                        'class_id': cls,
                        'class_name': result.names.get(cls, 'unknown')
                    })
            
            logger.info(f"Обнаружено {len(detected_objects)} объектов на изображении")
        
        # Если не нашли объекты через YOLO, добавляем все изображение как один объект
        if not detected_objects:
            # Получаем размеры изображения
            img = cv2.imread(image_path)
            height, width = img.shape[:2]
            detected_objects.append({
                'bbox': (0, 0, width, height),
                'confidence': 1.0,
                'class_id': -1,
                'class_name': 'full_image'
            })
            logger.info("Не обнаружено объектов, используем все изображение")
            
        return detected_objects
        
    except Exception as e:
        logger.error(f"Ошибка при обнаружении инструментов: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return []

# Функция для извлечения инструмента по координатам ограничивающей рамки
def extract_tool_by_bbox(image_path, bbox):
    """Извлекает изображение инструмента по координатам ограничивающей рамки"""
    try:
        # Загружаем изображение
        img = cv2.imread(image_path)
        if img is None:
            logger.error(f"Не удалось загрузить изображение: {image_path}")
            return None
            
        # Извлекаем координаты рамки
        x1, y1, x2, y2 = bbox
        
        # Проверяем границы
        height, width = img.shape[:2]
        x1 = max(0, x1)
        y1 = max(0, y1)
        x2 = min(width, x2)
        y2 = min(height, y2)
        
        # Вырезаем изображение инструмента
        cropped_img = img[y1:y2, x1:x2]
        
        # Проверяем, получилось ли что-то вырезать
        if cropped_img.size == 0:
            logger.warning(f"Получен пустой crop по координатам {bbox}")
            return None
            
        # Создаем временный файл для изображения инструмента
        temp_path = os.path.join("temp", f"tool_crop_{uuid.uuid4()}.jpg")
        cv2.imwrite(temp_path, cropped_img)
        
        return temp_path
        
    except Exception as e:
        logger.error(f"Ошибка при извлечении инструмента: {e}")
        import traceback
        logger.error(f"Детали ошибки: {traceback.format_exc()}")
        return None

def main():
    if not os.path.exists("config.encrypted"):
        logger.error("❌ Зашифрованный файл 'config.encrypted' не найден. Проверьте наличие.")
        return
    config = load_config()
    if not config:
        logger.error("❌ Программа завершена из-за некорректной или отсутствующей конфигурации.")
        return

    token = config.get("telegram_token")
    
    logger.info("⚠️ Cloudinary API отключено, будет использоваться только локальный поиск")
    
    # Инициализация моделей поиска изображений
    logger.info("🔄 Инициализация моделей поиска изображений...")
    try:
        if not initialize_image_search():
            logger.warning("⚠️ Ошибка инициализации моделей поиска изображений")
            logger.warning("Локальный поиск по изображениям будет недоступен")
        else:
            # Пробуем обновить индекс, если есть папка с фотографиями
            photos_folder = config.get("photos_folder")
            if photos_folder and os.path.exists(photos_folder):
                logger.info("🔄 Обновление индекса изображений...")
                if not update_image_index(photos_folder):
                    logger.warning("⚠️ Ошибка обновления локального индекса изображений")
                    logger.warning("Локальный поиск по изображениям может работать некорректно")
    except Exception as e:
        logger.error(f"❌ Ошибка при инициализации системы поиска изображений: {e}")
        logger.warning("Бот будет запущен без поддержки локального поиска по изображениям")
    
    # Инициализация аналитики
    analytics = Analytics()
    logger.info("Аналитика инициализирована")
    
    application = Application.builder().token(token).build()
    
    # Сохраняем аналитику в контексте бота
    application.bot_data['analytics'] = analytics

    # Изменяем порядок регистрации обработчиков
    # Сначала регистрируем обработчики команд
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_handler))
    application.add_handler(CommandHandler("stop", stop_handler))
    application.add_handler(CommandHandler("stats", get_stats_handler))
    
    # Затем регистрируем обработчики кнопок меню
    application.add_handler(MessageHandler(filters.Regex("^❓ Помощь$"), help_handler))
    application.add_handler(MessageHandler(filters.Regex("^📞 Контакты$"), contacts_handler))
    application.add_handler(MessageHandler(filters.Regex("^📸 Поиск по фото$"), photo_search_handler))
    
    # Обработчики для подразделов
    application.add_handler(MessageHandler(filters.Regex("^🏪 Магазины$"), stores_handler))
    application.add_handler(MessageHandler(filters.Regex("^🚚 Логистика$"), logistics_handler))
    application.add_handler(MessageHandler(filters.Regex("^🗺 Карты$"), maps_handler))
    application.add_handler(MessageHandler(filters.Regex("^🔧 Скобянка$"), skobyanka_handler))
    application.add_handler(MessageHandler(filters.Regex("^🎨 Цвета$"), colors_base_handler))
    application.add_handler(MessageHandler(filters.Regex("^📄 ЕГАИС$"), egais_handler))
    
    # Обработчики для кнопок навигации
    application.add_handler(MessageHandler(filters.Regex("^🔙 Назад в меню$"), back_to_menu_handler))
    application.add_handler(MessageHandler(filters.Regex("^🔙 Назад в контакты$"), back_to_contacts_handler))
    application.add_handler(MessageHandler(filters.Regex("^🔙 Назад к выбору отдела$"), back_to_departments_handler))

    # Обработчики для выбора отдела
    application.add_handler(MessageHandler(filters.Regex("^🎨 Краска$"), department_selection_handler))
    application.add_handler(MessageHandler(filters.Regex("^🧱 Стройка$"), department_selection_handler))
    application.add_handler(MessageHandler(filters.Regex("^🪑 Столярка$"), department_selection_handler))
    application.add_handler(MessageHandler(filters.Regex("^⚡ Электрика$"), department_selection_handler))
    application.add_handler(MessageHandler(filters.Regex("^🔨 Инструменты$"), department_selection_handler))
    application.add_handler(MessageHandler(filters.Regex("^🚿 Водоснабжение$"), department_selection_handler))
    application.add_handler(MessageHandler(filters.Regex("^🌱 Сад$"), department_selection_handler))
    application.add_handler(MessageHandler(filters.Regex("^🔧 Скобянка$"), department_selection_handler))

    # Добавляем обработчик статистики
    application.add_handler(MessageHandler(filters.Regex("^📊 Статистика$"), statistics_handler))

    # Добавляем обработчики админ-панели
    application.add_handler(CommandHandler("admin", admin_panel_handler))
    application.add_handler(MessageHandler(filters.Regex("^👥 Управление пользователями$"), user_management_handler))
    application.add_handler(MessageHandler(filters.Regex("^➕ Добавить пользователя$"), add_user_handler))
    application.add_handler(MessageHandler(filters.Regex("^➖ Удалить пользователя$"), remove_user_handler))
    application.add_handler(MessageHandler(filters.Regex("^📋 Список пользователей$"), list_users_handler))
    application.add_handler(MessageHandler(filters.Regex("^🔙 Назад в админ-панель$"), back_to_admin_panel_handler))

    # Общий обработчик текстовых сообщений должен быть последним
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler))
    
    # Добавляем обработчик команды add_user
    application.add_handler(CommandHandler("add_user", add_user_command))

    # Обработчик фотографий
    application.add_handler(MessageHandler(filters.PHOTO, photo_handler))

    # Запускаем бота
    logger.info("🤖 Бот запущен...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    logger.info("Проверяем наличие зашифрованного файла...")
    if not os.path.exists("config.encrypted"):
        logger.error("❌ Зашифрованный файл 'config.encrypted' не найден. Проверьте наличие.")
        exit()  # Завершаем программу
    logger.info("Файл найден.")

    logger.info("Загружаем конфигурацию...")
    config = load_config()
    if not config:
        logger.error("❌ Программа завершена из-за некорректной или отсутствующей конфигурации.")
        exit()

    logger.info("Конфигурация успешно загружена.")
    logger.info("Запуск бота...")
    main()